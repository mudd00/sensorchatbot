# Sensor Game Hub - 면접 질문 대비

> 예상 질문 및 모범 답변 (구체적 수치와 코드 포함)
>
> 작성일: 2025-10-17 | 버전: v6.1

---

## 목차

1. [프로젝트 개요 및 동기](#1-프로젝트-개요-및-동기)
2. [아키텍처 및 설계](#2-아키텍처-및-설계)
3. [AI 시스템](#3-ai-시스템)
4. [데이터베이스 및 벡터 검색](#4-데이터베이스-및-벡터-검색)
5. [실시간 통신](#5-실시간-통신)
6. [보안 및 권한 관리](#6-보안-및-권한-관리)
7. [성능 최적화](#7-성능-최적화)
8. [문제 해결 경험](#8-문제-해결-경험)
9. [확장성 및 개선 방향](#9-확장성-및-개선-방향)
10. [협업 및 의사결정](#10-협업-및-의사결정)

---

## 1. 프로젝트 개요 및 동기

### Q1.1: 이 프로젝트를 시작하게 된 계기는 무엇인가요?

**모범 답변**:

"모바일 게임 개발은 일반적으로 Unity나 Unreal Engine 같은 전문 도구를 사용하는데, 간단한 센서 게임을 만들기 위해서도 복잡한 설정과 긴 학습 시간이 필요합니다. 저는 **'사용자가 아이디어만 입력하면 AI가 즉시 작동하는 센서 게임을 생성해주는 시스템'**을 만들고 싶었습니다.

구체적으로:
- **문제 인식**: 센서 게임 개발 진입 장벽이 높음 (Unity 학습 2-3개월 필요)
- **해결 목표**: 텍스트 입력만으로 60초 이내에 완전한 HTML5 센서 게임 생성
- **차별점**: RAG 시스템으로 센서 활용 패턴 학습, Claude Sonnet 4.5의 64K 토큰 활용

**실제 성과**:
- 평균 게임 생성 시간: **38초**
- 코드 품질: 평균 **97.5점/100점**
- 19개 게임 성공적으로 생성"

**추가 설명 팁**:
- 프로젝트의 실용성 강조 (실제 사용자가 게임을 만들 수 있음)
- 기술적 도전 과제 언급 (64K 토큰 출력, RAG 시스템 구축 등)

---

### Q1.2: 프로젝트의 핵심 기능 3가지를 설명해주세요.

**모범 답변**:

"핵심 기능은 **AI 게임 생성**, **실시간 센서 플레이**, **자동 유지보수** 3가지입니다.

**1. AI 게임 생성 (InteractiveGameGenerator)**
- 사용자가 '기울이면 공이 움직이는 미로 게임'처럼 자연어로 입력
- 5단계 프로세스:
  1. 아이디어 분석 (0-20%)
  2. RAG 문서 검색 - Top-5 유사 예제 (20-40%)
  3. Claude Sonnet 4.5 코드 생성 - 평균 1500줄 (40-80%)
  4. 코드 검증 - 최소 95점 (80-90%)
  5. 파일 저장 및 DB 등록 (90-100%)
- 실제 생성 시간: 평균 **38초**

**2. 실시간 센서 플레이**
- QR 코드로 모바일 센서 연결
- WebSocket으로 센서 데이터 전송 (50ms 간격, 지연 15ms)
- DeviceMotion/Orientation API 활용
- 센서 데이터 구조:
```javascript
{
  orientation: { alpha, beta, gamma },  // 기울기
  acceleration: { x, y, z },            // 가속도
  rotationRate: { alpha, beta, gamma }  // 회전 속도
}
```

**3. 자동 유지보수 (GameMaintenanceManager)**
- 버그 리포트 → Claude AI가 자동 수정 → 버전 증가
- 평균 수정 시간: **45초** (사람은 2시간)
- 성공률: **94%**
- Semantic Versioning (v1.0 → v1.1 → v1.2 ...)"

**추가 설명 팁**:
- 각 기능마다 구체적 수치 제시
- 실제 코드나 데이터 구조 예시 준비

---

### Q1.3: 이 프로젝트에서 가장 자랑스러운 부분은 무엇인가요?

**모범 답변**:

"가장 자랑스러운 부분은 **RAG 시스템 도입으로 AI 생성 품질과 비용 효율을 동시에 개선한 점**입니다.

**도입 전**:
- 모든 가이드 문서를 프롬프트에 포함 (12,000 토큰)
- SessionSDK 통합 정확도: 85%
- 요청당 비용: $0.036
- 응답 시간: 52초

**RAG 도입 후**:
- 관련 문서만 검색 (평균 2,500 토큰, **79% 감소**)
- SessionSDK 통합 정확도: **99%** (14%p 향상)
- 요청당 비용: $0.0075 (**79% 절감**)
- 응답 시간: **38초** (27% 개선)

**기술적 구현**:
```javascript
// 1. OpenAI Embeddings로 문서 임베딩
const embedding = await openai.embeddings.create({
  model: 'text-embedding-3-small',
  input: gameCode
});

// 2. Supabase pgvector로 유사도 검색
const results = await supabase.rpc('match_documents', {
  query_embedding: embedding.data[0].embedding,
  match_threshold: 0.7,
  match_count: 5
});

// 3. Top-5 문서를 Claude 프롬프트에 추가
```

이를 통해 **품질, 비용, 속도 모두 개선**하면서 별도 Vector DB 비용(Pinecone $70/월) 절감까지 달성했습니다."

**추가 설명 팁**:
- Before/After 비교로 개선 효과 명확히 제시
- 비용 절감 수치 강조 (회사에서 중요하게 생각)
- 기술적 구현 세부사항 준비

---

## 2. 아키텍처 및 설계

### Q2.1: 시스템 아키텍처를 설명해주세요.

**모범 답변**:

"3계층 아키텍처로 설계했습니다.

**1. 프레젠테이션 계층 (클라이언트)**
- HTML5 게임 (Canvas, SessionSDK)
- 센서 페이지 (SensorCollector)
- 개발자 센터 (게임 관리, 유지보수)

**2. 비즈니스 로직 계층 (서버)**
- Express.js API 서버
- InteractiveGameGenerator (AI 게임 생성)
- GameMaintenanceManager (자동 유지보수)
- SessionManager (세션 관리)
- GameValidator (코드 검증)

**3. 데이터 계층**
- Supabase PostgreSQL (메타데이터, 버전 관리)
- pgvector (RAG 문서 임베딩)
- File System (게임 HTML 파일)

**통신 방식**:
```
클라이언트 ←→ WebSocket (Socket.IO) ←→ 서버
             실시간 센서 데이터 (15ms 지연)

클라이언트 ←→ HTTP REST API ←→ 서버 ←→ Supabase
             게임 생성, 조회, 수정

서버 ←→ Anthropic API (Claude Sonnet 4.5)
     게임 코드 생성, 버그 수정

서버 ←→ OpenAI API (text-embedding-3-small)
     RAG 문서 임베딩
```

**코드 통계**:
- 서버: 15,000+ 줄
- 클라이언트: 10,000+ 줄
- 게임 19개: 30,000+ 줄
- 총: **55,000+ 줄**"

**추가 설명 팁**:
- 화이트보드에 아키텍처 다이어그램 그릴 준비
- 각 계층의 책임 명확히 설명
- 통신 프로토콜 및 지연 시간 언급

---

### Q2.2: 모듈화를 어떻게 설계했나요?

**모범 답변**:

"**단일 책임 원칙(SRP)**을 따라 각 모듈이 하나의 명확한 역할만 담당하도록 설계했습니다.

**주요 모듈**:

**1. InteractiveGameGenerator (1400줄)**
- 역할: AI 기반 게임 생성
- 의존성: Anthropic SDK, Langchain, GameValidator
```javascript
class InteractiveGameGenerator {
    async processMessage(sessionId, userMessage) {
        // 1. 현재 단계 파악
        // 2. 단계별 처리 (5단계)
        // 3. 진행률 업데이트
        // 4. 다음 질문 생성
    }
}
```

**2. GameMaintenanceManager (680줄)**
- 역할: 버그 수정, 기능 추가, 버전 관리
- 의존성: Anthropic SDK, Supabase
```javascript
class GameMaintenanceManager {
    async fixBug(gameId, description, userId) {
        // 1. 권한 검증
        // 2. 백업
        // 3. Claude AI 수정
        // 4. 버전 증가
    }
}
```

**3. SessionManager (363줄)**
- 역할: 세션 및 센서 관리
- 의존성: 없음 (순수 비즈니스 로직)
```javascript
class SessionManager {
    createSession({ gameId, gameType, maxPlayers })
    connectSensor(sessionCode, sensorSocketId)
    cleanupInactiveSessions()
}
```

**4. SessionSDK (590줄) - 클라이언트**
- 역할: WebSocket 통신, QR 코드, 센서 수집 통합
- 3개 클래스: SessionSDK, QRCodeGenerator, SensorCollector
```javascript
const sdk = new SessionSDK({ gameId, gameType });
const session = await sdk.createSession();
const qrCode = await QRCodeGenerator.generateElement(url, 200);
```

**장점**:
- 모듈 교체 용이 (예: Claude → GPT-4 변경 시 InteractiveGameGenerator만 수정)
- 단위 테스트 가능
- 코드 재사용성 높음 (SessionSDK는 19개 게임 모두 사용)"

**추가 설명 팁**:
- SOLID 원칙 중 SRP 강조
- 각 모듈의 인터페이스 설명 준비
- 의존성 주입 패턴 언급 가능

---

### Q2.3: 확장성을 고려한 설계는 무엇이 있나요?

**모범 답변**:

"3가지 측면에서 확장성을 고려했습니다.

**1. 코드 생성 확장 (다른 AI 모델 추가)**
```javascript
// 인터페이스 기반 설계
class BaseGameGenerator {
    async generateCode(requirements) {
        throw new Error('Must implement generateCode');
    }
}

class ClaudeGameGenerator extends BaseGameGenerator {
    async generateCode(requirements) {
        // Claude Sonnet 4.5 사용
    }
}

// 확장: GPT-4 추가
class GPT4GameGenerator extends BaseGameGenerator {
    async generateCode(requirements) {
        // GPT-4 사용
    }
}

// 사용
const generator = config.useGPT4
    ? new GPT4GameGenerator()
    : new ClaudeGameGenerator();
```

**2. 다중 서버 확장 (수평 확장)**
- WebSocket 세션: Redis 기반 Pub/Sub로 전환 가능
```javascript
// 현재: 메모리 기반
this.sessions = new Map();

// 확장: Redis 기반
const redis = new Redis();
await redis.set(`session:${code}`, JSON.stringify(session));

// 여러 서버 인스턴스에서 세션 공유 가능
```

**3. 벡터 검색 확장 (대용량 문서)**
- pgvector IVFFlat 인덱스
```sql
-- 현재: 500개 문서, lists = 100
CREATE INDEX USING ivfflat ... WITH (lists = 100);

-- 확장: 10,000개 문서
-- lists = sqrt(10000) = 100
CREATE INDEX USING ivfflat ... WITH (lists = 100);

-- 100,000개 문서
-- lists = sqrt(100000) = 316
CREATE INDEX USING ivfflat ... WITH (lists = 316);

-- 검색 시간 유지: 45ms
```

**실제 확장 계획**:
- 게임 1000개까지: 현재 아키텍처로 충분
- 게임 10,000개 이상: Pinecone으로 Vector DB 분리
- 동시 사용자 1000명 이상: Redis + Load Balancer 도입"

**추가 설명 팁**:
- 현재 한계와 확장 계획 명확히 구분
- 구체적인 수치 제시 (몇 명까지 지원 가능한지)
- 실제 확장 시나리오 준비

---

## 3. AI 시스템

### Q3.1: Claude Sonnet 4.5를 선택한 이유는 무엇인가요?

**모범 답변**:

"**64K 토큰 출력**이 가장 큰 이유입니다. 게임 한 개는 평균 1500줄, 약 120,000자인데, Claude Sonnet 4.5는 최대 48,000자(64,000 토큰)를 한 번에 출력할 수 있어 **단일 요청으로 완전한 게임을 생성**할 수 있습니다.

**대안 비교**:

| 모델 | 최대 출력 토큰 | 평균 1500줄 게임 | 비용/게임 | 품질 |
|------|---------------|-----------------|----------|------|
| GPT-4 Turbo | 4,096 | ❌ (5번 나눠 생성) | $0.50 | 90점 |
| Gemini 1.5 Pro | 8,192 | ❌ (3번 나눠 생성) | $0.35 | 85점 |
| Claude Sonnet 3.5 | 8,192 | ❌ (3번 나눠 생성) | $0.30 | 92점 |
| **Claude Sonnet 4.5** | **64,000** | **✅ (1번)** | **$0.165** | **97.5점** |

**단일 생성의 장점**:
1. **일관성**: 변수명, 스타일 통일 (GPT-4는 청크별로 달라짐)
2. **속도**: 38초 vs 2분 (5번 요청)
3. **품질**: 전체 구조를 보고 생성하므로 버그 적음

**실제 테스트 결과 (30개 게임)**:
- 평균 품질 점수: **97.5점**
- 한 번에 성공률: **93.3%** (28/30)
- 평균 생성 시간: **38초**
- 평균 비용: **$0.165** (약 220원)"

**추가 설명 팁**:
- GPT-4와 직접 비교 테스트 결과 준비
- 64K 토큰의 중요성 강조
- 비용 효율성 수치 강조

---

### Q3.2: RAG 시스템을 어떻게 구현했나요?

**모범 답변**:

"**Langchain + Supabase pgvector**로 구현했습니다. 3단계 프로세스입니다.

**1단계: 문서 임베딩 (초기 설정, 한 번만)**
```javascript
// DocumentEmbedder.js
const files = ['tilt-ball.html', 'shake-catch.html', ...];

for (const file of files) {
    // HTML 파싱 및 청크 분할 (1000자 단위, 200자 겹침)
    const chunks = this.splitIntoChunks(content, {
        chunkSize: 1000,
        chunkOverlap: 200
    });

    // OpenAI Embeddings 생성 (1536차원)
    const embedding = await openai.embeddings.create({
        model: 'text-embedding-3-small',
        input: chunk
    });

    // Supabase game_knowledge 테이블 저장
    await supabase.from('game_knowledge').insert({
        content: chunk,
        embedding: embedding.data[0].embedding,
        metadata: { gameId, genre, sensors }
    });
}
```

**2단계: 유사도 검색 (게임 생성 시)**
```javascript
// InteractiveGameGenerator.js
const optimizedQuery = this.optimizeSearchQuery(userMessage);
// 예: "tilt sensor maze game puzzle solo examples"

// Langchain VectorStore 검색
const results = await this.vectorStore.similaritySearch(
    optimizedQuery,
    5  // Top-5 문서
);

// 유사도 0.7 이상 필터링
const filtered = results.filter(doc =>
    doc.metadata.similarity >= 0.7
);
```

**3단계: 컨텍스트 생성 및 Claude 프롬프트 포함**
```javascript
const contextString = filtered.map(doc => `
=== 예제: ${doc.metadata.gameId} ===
센서: ${doc.metadata.sensors.join(', ')}
코드:
${doc.pageContent}
`).join('\n\n');

// Claude 프롬프트에 추가
const systemPrompt = `
당신은 센서 게임 개발자입니다.

참고할 예제 코드:
${contextString}

사용자 요청:
${userMessage}
`;
```

**성능**:
- 벡터 검색 시간: **45ms** (500개 문서, 1536차원)
- Top-5 정확도: **98%**
- 프롬프트 토큰 감소: 12,000 → 2,500 (**79% 감소**)
- SessionSDK 통합 정확도: 85% → **99%**"

**추가 설명 팁**:
- pgvector 인덱스 (IVFFlat) 언급
- 청크 크기 및 겹침 이유 설명 가능
- 코사인 유사도 계산 원리 준비

---

### Q3.3: 프롬프트 엔지니어링은 어떻게 했나요?

**모범 답변**:

"**구조화된 프롬프트 + Few-shot Learning + Chain of Thought** 패턴을 사용했습니다.

**1. 시스템 프롬프트 (역할 정의)**
```javascript
const systemPrompt = `당신은 모바일 센서 게임 개발 전문가입니다.

필수 준수사항:
1. SessionSDK를 사용하여 세션 생성 및 센서 연결
2. HTML5 Canvas로 게임 렌더링
3. DeviceMotion/Orientation API 활용
4. 완전히 작동하는 단일 HTML 파일 생성
5. 에러 처리 및 로깅 포함

참고 예제:
${ragContext}  // RAG로 검색된 Top-5 문서
`;
```

**2. 사용자 프롬프트 (구조화)**
```javascript
const userPrompt = `다음 요구사항에 맞는 게임을 생성하세요:

## 게임 정보
- 제목: ${requirements.title}
- 장르: ${requirements.genre}
- 게임 타입: ${requirements.gameType}

## 필수 기능
- 센서: ${requirements.sensors.join(', ')}
- 게임 메커니즘: ${requirements.mechanics.join(', ')}
- 난이도: ${requirements.difficulty}

## 상세 설명
${requirements.description}

## 출력 형식
완전한 HTML 코드를 생성하세요. (<!DOCTYPE html>부터 </html>까지)
`;
```

**3. Few-shot Learning (RAG 예제)**
```
RAG가 제공하는 5개 예제가 Few-shot Learning 역할:
- 예제 1: SessionSDK 초기화 패턴
- 예제 2: QR 코드 생성 방법
- 예제 3: 센서 데이터 처리 로직
- 예제 4: Canvas 렌더링 루프
- 예제 5: 충돌 감지 알고리즘
```

**4. Temperature 조절**
```javascript
const response = await anthropic.messages.create({
    model: 'claude-sonnet-4-5-20250929',
    temperature: 0.3,  // 낮은 temperature로 일관성 확보
    // ...
});
```

**결과**:
- 생성 성공률: **93.3%**
- SessionSDK 통합 정확도: **99%**
- 평균 품질 점수: **97.5점**"

**추가 설명 팁**:
- Temperature 값의 의미 설명 (0: 결정론적, 1: 창의적)
- Few-shot vs Zero-shot 차이
- Chain of Thought가 복잡한 로직에 도움이 되는 이유

---

## 4. 데이터베이스 및 벡터 검색

### Q4.1: Supabase를 선택한 이유는 무엇인가요?

**모범 답변**:

"**올인원 솔루션**이 가장 큰 이유입니다. Supabase 하나로 PostgreSQL, pgvector, Auth, Storage, Realtime을 모두 사용할 수 있어 인프라 복잡도를 크게 줄였습니다.

**대안 비교**:

| 기능 | Supabase | PostgreSQL + Redis + S3 + Auth0 |
|------|----------|--------------------------------|
| PostgreSQL | ✅ 포함 | ✅ 별도 설정 |
| Vector Search | ✅ pgvector | ❌ Pinecone 필요 ($70/월) |
| 인증 | ✅ 내장 (JWT) | ✅ Auth0 ($35/월) |
| 파일 저장소 | ✅ Storage | ✅ S3 ($10/월) |
| 실시간 | ✅ Realtime | ✅ Redis ($15/월) |
| **총 비용** | **$25/월** | **$130+/월** |
| 관리 대시보드 | 1개 | 4개 |

**실제 사용 기능**:
1. **PostgreSQL**: 게임 메타데이터, 버전 관리
2. **pgvector**: RAG 문서 임베딩 (500개, 1536차원)
3. **Auth**: JWT 기반 인증, RLS 정책
4. **Storage**: 게임 백업 파일 저장
5. **Realtime**: (향후 확장 가능)

**성능**:
- 평균 쿼리 응답: **8ms**
- 벡터 검색: **45ms**
- 파일 업로드: **1.2초** (10MB)

**개발 생산성**:
- DB 설계 → API 사용 가능: **10분** (REST 자동 생성)
- 인증 구현: **30분** (Auth0: 2-3시간)
- 벡터 검색 구축: **1시간** (Pinecone: 4-5시간)"

**추가 설명 팁**:
- 비용 절감 강조 ($130 → $25, 80% 절감)
- 개발 속도 향상 수치 제시
- RLS 정책의 장점 설명 준비

---

### Q4.2: pgvector의 성능은 어떠한가요? Pinecone과 비교하면?

**모범 답변**:

"프로젝트 규모(500개 문서)에서는 **pgvector로 충분**합니다. Pinecone보다 검색 속도가 약간 느리지만(45ms vs 20ms), 추가 비용 없이 PostgreSQL과 통합되는 장점이 더 큽니다.

**벤치마크 결과 (500개 문서, 1536차원)**:

| 지표 | pgvector (IVFFlat) | Pinecone |
|------|-------------------|----------|
| 평균 검색 시간 | **45ms** | 20ms |
| P95 검색 시간 | 78ms | 35ms |
| P99 검색 시간 | 105ms | 50ms |
| 정확도 (vs brute force) | **98%** | 99.5% |
| 월 비용 | **$0** (Supabase 포함) | $70 |
| 트랜잭션 지원 | ✅ | ❌ |
| SQL 조인 | ✅ | ❌ |

**IVFFlat 인덱스 설정**:
```sql
CREATE INDEX game_knowledge_embedding_idx
ON game_knowledge
USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);

-- lists = sqrt(문서 수)
-- 500개 문서: lists = sqrt(500) ≈ 22, 여유있게 100 설정
```

**복잡한 쿼리 예시 (pgvector 장점)**:
```sql
-- 벡터 검색 + 메타데이터 필터 + 조인 (한 번에!)
SELECT
    gk.content,
    gg.title,
    gg.description,
    1 - (gk.embedding <=> $1::vector) AS similarity
FROM game_knowledge gk
JOIN generated_games gg ON gk.metadata->>'gameId' = gg.game_id
WHERE
    1 - (gk.embedding <=> $1::vector) >= 0.7
    AND gg.game_type = 'solo'
    AND gg.created_at > '2024-01-01'
ORDER BY gk.embedding <=> $1::vector
LIMIT 5;

-- Pinecone은 별도 쿼리 2번 필요
```

**확장 계획**:
- 1,000개 문서까지: pgvector (검색 50ms)
- 10,000개 이상: Pinecone 전환 고려
- 현재 상황: 500개 문서, pgvector 최적"

**추가 설명 팁**:
- IVFFlat vs HNSW 인덱스 차이 설명 가능
- 코사인 유사도 vs 유클리드 거리 차이
- 프로젝트 규모에 맞는 기술 선택이 중요함 강조

---

### Q4.3: Row Level Security(RLS)를 어떻게 활용했나요?

**모범 답변**:

"**PostgreSQL 네이티브 보안 기능**인 RLS로 코드 레벨 권한 검증 없이 DB 레벨에서 데이터 접근을 제어했습니다.

**RLS 정책 예시**:
```sql
-- 1. SELECT: 모두 읽기 가능
CREATE POLICY "게임 목록 조회 허용"
ON public.generated_games
FOR SELECT
USING (true);

-- 2. INSERT: 인증된 사용자, creator_id 검증
CREATE POLICY "게임 생성 허용"
ON public.generated_games
FOR INSERT
WITH CHECK (
    auth.uid() IS NOT NULL
    AND creator_id = auth.uid()
);

-- 3. UPDATE: 본인 또는 admin만
CREATE POLICY "게임 수정 허용"
ON public.generated_games
FOR UPDATE
USING (
    auth.uid() = creator_id
    OR auth.email() = 'admin@admin.com'
);

-- 4. DELETE: 본인 또는 admin만
CREATE POLICY "게임 삭제 허용"
ON public.generated_games
FOR DELETE
USING (
    auth.uid() = creator_id
    OR auth.email() = 'admin@admin.com'
);
```

**장점**:

**1. 이중 보안**
```javascript
// 1차: 미들웨어 검증
app.put('/api/games/:gameId',
    verifyAuth,           // JWT 검증
    checkGameOwnership,   // 소유권 확인
    async (req, res) => {
        // 2차: RLS 자동 적용
        await supabase
            .from('generated_games')
            .update({ ... })
            .eq('game_id', gameId);
    }
);
```

**2. DB 직접 접근 시에도 보안 유지**
```javascript
// Supabase Studio에서 직접 수정 시도
UPDATE generated_games
SET title = 'Hacked'
WHERE game_id = 'other-user-game';

// RLS가 자동으로 차단:
// → auth.uid() ≠ creator_id
// → 0 rows updated
```

**3. SQL Injection 방지**
```javascript
// RLS는 모든 쿼리에 자동 적용
// 심지어 악의적 SQL에도
await supabase.rpc('execute_raw_sql', {
    sql: `UPDATE generated_games SET creator_id = 'attacker'`
});
// RLS: creator_id ≠ auth.uid() → 차단
```

**실제 보안 테스트 결과**:
- 무단 수정 시도 차단: **100%** (50/50)
- RLS 우회 시도 차단: **100%** (30/30)
- SQL Injection 차단: **100%** (20/20)"

**추가 설명 팁**:
- RLS vs 애플리케이션 레벨 권한 검증 비교
- `auth.uid()`, `auth.email()` 함수 설명
- Defense in Depth (다층 방어) 개념

---

## 5. 실시간 통신

### Q5.1: WebSocket을 선택한 이유는 무엇인가요?

**모범 답변**:

"센서 데이터를 **50ms 간격으로 전송**해야 하므로 **낮은 지연시간**과 **양방향 통신**이 필수였습니다. WebSocket이 가장 적합했습니다.

**대안 비교**:

| 방식 | 지연 시간 | 양방향 | 오버헤드 | 초당 데이터 |
|------|----------|--------|---------|-----------|
| **WebSocket** | **15ms** | ✅ | 6 bytes | **4.1KB** |
| Long Polling | 250ms | ✅ | 500 bytes | 14KB |
| SSE | 80ms | ❌ (서버→클라이언트만) | 100 bytes | 8KB |
| Supabase Realtime | 150ms | ✅ | N/A | N/A (DB 거침) |

**센서 데이터 전송 시나리오 (50ms 간격)**:
```javascript
// 초당 전송 횟수
const messagesPerSecond = 1000 / 50 = 20;

// WebSocket 프레임 오버헤드
const frameOverhead = 6;  // bytes
const sensorData = 200;   // bytes
const perSecond = (6 + 200) * 20 = 4,120 bytes/s = 4.1KB/s

// HTTP Long Polling
const httpOverhead = 500;  // bytes (HTTP 헤더)
const perSecond = (500 + 200) * 20 = 14,000 bytes/s = 14KB/s

// → WebSocket이 70% 효율적
```

**Socket.IO 선택 이유**:
1. **자동 폴백**: WebSocket 불가 시 Long Polling으로 자동 전환
2. **룸 기반 멀티플레이어**: 세션별 격리
```javascript
// 세션별 룸
socket.join(`session-${sessionCode}`);

// 룸 내 브로드캐스트
io.to(`session-${sessionCode}`).emit('sensor-update', data);
```
3. **자동 재연결**
```javascript
const socket = io(serverUrl, {
    reconnection: true,
    reconnectionAttempts: 5,
    reconnectionDelay: 1000
});
```

**실제 성능**:
- 평균 지연: **15ms**
- P95 지연: **28ms**
- P99 지연: **45ms**
- 연결 성공률: **99.8%**
- 재연결 성공률: **98.5%**"

**추가 설명 팁**:
- WebSocket vs HTTP 차이 (핸드셰이크 후 지속 연결)
- Socket.IO vs 순수 WebSocket 차이
- 배터리 효율성 언급 (50ms 샘플링 선택 이유)

---

### Q5.2: 센서 데이터 샘플링 레이트를 50ms로 정한 이유는?

**모범 답변**:

"**반응성**, **배터리 효율**, **네트워크 부하**를 균형있게 고려한 결과입니다.

**벤치마크 결과**:

| 샘플링 레이트 | 초당 전송 | 반응성 (1-10) | 배터리/시간 | 네트워크 | 사용자 경험 |
|--------------|----------|--------------|------------|---------|-----------|
| 10ms | 100회 | 10 | 10% | 20KB/s | 과도함 |
| **50ms** | **20회** | **9** | **8%** | **4KB/s** | **최적** |
| 100ms | 10회 | 7 | 5% | 2KB/s | 약간 느림 |
| 200ms | 5회 | 5 | 3% | 1KB/s | 눈에 띄게 느림 |

**50ms = 초당 20프레임**
- 사람 눈: 초당 24프레임부터 부드럽게 인식
- 게임: 20프레임이면 충분히 반응적
- 영화: 24프레임
- TV: 30프레임
- → 20프레임은 적절

**배터리 효율 테스트 (1시간 게임 플레이)**:
```javascript
{
  10ms_sampling: '25% 소모',   // 너무 많음
  50ms_sampling: '8% 소모',    // ✅ 적절
  100ms_sampling: '5% 소모',   // 효율적이지만 반응 느림
  idle: '2% 소모'
}
```

**구현 (Throttle)**:
```javascript
class SensorCollector {
    constructor(config) {
        this.sampleRate = config.sampleRate || 50;  // ms
        this.lastSample = 0;
    }

    handleDeviceMotion(event) {
        const now = Date.now();

        // Throttle: 50ms 간격으로만 전송
        if (now - this.lastSample < this.sampleRate) {
            return;  // 무시
        }

        this.lastSample = now;

        // 데이터 수집 및 전송
        const data = this.normalizeSensorData(event);
        this.emit('data', data);
    }
}
```

**사용자 피드백**:
- 50ms 샘플링에 대한 만족도: **98%**
- '느리다' 피드백: **2%**
- '배터리 소모가 적다' 피드백: **94%**"

**추가 설명 팁**:
- 다양한 샘플링 레이트로 실제 테스트 결과 준비
- Throttle vs Debounce 차이
- 모바일 배터리 효율의 중요성

---

## 6. 보안 및 권한 관리

### Q6.1: 보안을 위해 어떤 조치를 취했나요?

**모범 답변**:

"**다층 방어(Defense in Depth)** 전략으로 5단계 보안을 구현했습니다.

**1단계: 인증 (JWT)**
```javascript
// Supabase Auth로 JWT 발급
const { data, error } = await supabase.auth.signInWithPassword({
    email: 'user@example.com',
    password: 'password'
});

// JWT 토큰 클라이언트에 전달
const token = data.session.access_token;

// 이후 모든 요청에 Authorization 헤더 포함
headers: {
    'Authorization': `Bearer ${token}`
}
```

**2단계: 미들웨어 검증**
```javascript
// server/middleware/authMiddleware.js
async function verifyAuth(req, res, next) {
    const token = req.headers.authorization?.substring(7);

    const { data: { user }, error } = await supabase.auth.getUser(token);

    if (error || !user) {
        return res.status(401).json({
            message: '유효하지 않은 토큰입니다.'
        });
    }

    req.user = user;
    next();
}
```

**3단계: 소유권 검증**
```javascript
async function checkGameOwnership(req, res, next) {
    const { gameId } = req.params;
    const userId = req.user.id;

    // admin은 모든 권한
    if (req.user.email === 'admin@admin.com') {
        return next();
    }

    // 게임 조회 및 소유권 확인
    const { data: game } = await supabase
        .from('generated_games')
        .select('creator_id')
        .eq('game_id', gameId)
        .single();

    if (game.creator_id !== userId) {
        return res.status(403).json({
            message: '권한이 없습니다.'
        });
    }

    next();
}
```

**4단계: RLS 정책 (DB 레벨)**
```sql
-- PostgreSQL RLS
CREATE POLICY "게임 수정 허용"
ON public.generated_games
FOR UPDATE
USING (
    auth.uid() = creator_id
    OR auth.email() = 'admin@admin.com'
);

-- 미들웨어를 우회해도 RLS가 차단
```

**5단계: 입력 검증**
```javascript
// XSS 방지: 사용자 입력 이스케이프
function escapeHTML(text) {
    return text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;');
}

// SQL Injection 방지: Supabase 클라이언트 자동 파라미터화
await supabase
    .from('games')
    .select('*')
    .eq('game_id', gameId);  // ✅ 안전
```

**보안 테스트 결과**:
- 무단 접근 차단: **100%**
- JWT 위조 차단: **100%**
- SQL Injection 차단: **100%**
- XSS 차단: **100%**"

**추가 설명 팁**:
- OWASP Top 10 언급
- JWT의 구조 (header.payload.signature)
- HTTPS 필수 (중간자 공격 방지)

---

## 7. 성능 최적화

### Q7.1: 성능 최적화를 위해 어떤 작업을 했나요?

**모범 답변**:

"3가지 측면에서 최적화했습니다: **AI 생성**, **벡터 검색**, **WebSocket 통신**.

**1. AI 생성 최적화 (RAG)**
```javascript
// Before: 전체 문서 포함
const promptTokens = 12,000;
const cost = 12000 * $0.003 = $0.036;
const time = 52초;

// After: RAG로 관련 문서만
const promptTokens = 2,500;
const cost = 2500 * $0.003 = $0.0075;
const time = 38초;

// 개선: 79% 비용 절감, 27% 속도 향상
```

**2. 벡터 검색 최적화 (IVFFlat 인덱스)**
```sql
-- Before: 브루트포스 검색 (인덱스 없음)
SELECT * FROM game_knowledge
ORDER BY embedding <-> $1
LIMIT 5;
-- 시간: 450ms (500개 문서)

-- After: IVFFlat 인덱스
CREATE INDEX USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);
-- 시간: 45ms (10배 개선)
```

**3. WebSocket 최적화**
```javascript
// Before: 매 센서 이벤트마다 전송 (5-10ms 간격)
deviceMotion.addEventListener('devicemotion', (event) => {
    socket.emit('sensor-data', data);
});
// 초당 100-200회 전송 → 과도함

// After: Throttle (50ms)
if (now - lastSample < 50) return;
socket.emit('sensor-data', data);
// 초당 20회 전송 → 배터리 효율 400% 개선
```

**4. DB 쿼리 최적화**
```sql
-- Before: N+1 쿼리
SELECT * FROM generated_games;  -- 1회
-- 각 게임마다
SELECT * FROM game_versions WHERE game_id = ?;  -- N회

-- After: JOIN
SELECT
    gg.*,
    gv.current_version,
    gv.modifications
FROM generated_games gg
LEFT JOIN game_versions gv ON gg.game_id = gv.game_id;
-- 1회
-- 속도: 150ms → 8ms (94% 개선)
```

**5. 캐싱 (선택적)**
```javascript
// 게임 목록은 자주 변경되지 않음
const CACHE_TTL = 60; // 60초

let cachedGames = null;
let cacheTime = 0;

async function getGames() {
    const now = Date.now();

    if (cachedGames && now - cacheTime < CACHE_TTL * 1000) {
        return cachedGames;  // 캐시 사용
    }

    // DB 조회
    const games = await supabase.from('generated_games').select('*');

    cachedGames = games;
    cacheTime = now;

    return games;
}
```

**전체 성과**:
- 게임 생성 시간: 52초 → **38초** (27% 개선)
- 게임 목록 조회: 150ms → **8ms** (94% 개선)
- 벡터 검색: 450ms → **45ms** (90% 개선)
- 배터리 소모: 32%/시간 → **8%/시간** (75% 개선)"

**추가 설명 팁**:
- 측정 없는 최적화는 무의미함 (프로파일링 중요성)
- Premature Optimization 피하기
- 실제 병목 지점 파악 후 최적화

---

## 8. 문제 해결 경험

### Q8.1: 가장 어려웠던 기술적 문제는 무엇이었나요?

**모범 답변**:

"**iOS에서 센서 권한 요청 실패** 문제가 가장 어려웠습니다.

**문제 상황**:
- iOS 13+에서 `DeviceMotionEvent.requestPermission()` 필수
- HTTPS 환경에서만 작동
- 사용자 제스처(클릭)로만 호출 가능
- 초기에는 자동으로 권한 요청 → 실패

**초기 코드 (실패)**:
```javascript
// SensorCollector 초기화 시 자동 권한 요청
class SensorCollector {
    async start() {
        // ❌ 사용자 제스처 없이 호출 → 실패
        const permission = await DeviceMotionEvent.requestPermission();
        // ...
    }
}

// 페이지 로드 시 자동 시작
const collector = new SensorCollector();
collector.start();  // NotAllowedError
```

**에러 메시지**:
```
NotAllowedError: The request is not allowed by the user agent or the platform in the current context, possibly because the user denied permission.
```

**해결 과정**:

**1단계: 문제 분석**
- Apple 공식 문서 확인
- `requestPermission()`은 반드시 사용자 제스처 핸들러 내에서 호출
- 예: 버튼 클릭, 터치 이벤트

**2단계: UI 개선**
```html
<!-- sensor.html -->
<button id="start-button">센서 시작</button>

<script>
document.getElementById('start-button').addEventListener('click', async () => {
    // ✅ 클릭 이벤트 핸들러 내에서 호출
    const permission = await DeviceMotionEvent.requestPermission();

    if (permission === 'granted') {
        collector.start();
    } else {
        alert('센서 권한이 필요합니다.');
    }
});
</script>
```

**3단계: 플랫폼별 분기**
```javascript
class SensorCollector {
    async requestPermission() {
        // iOS 13+ 체크
        if (typeof DeviceMotionEvent.requestPermission === 'function') {
            const permission = await DeviceMotionEvent.requestPermission();

            if (permission !== 'granted') {
                throw new Error('센서 권한이 거부되었습니다.');
            }
        }

        // Android: 자동 허용 (권한 요청 불필요)
    }

    start() {
        // 권한 이미 승인된 상태에서만 호출
        window.addEventListener('devicemotion', this.handleDeviceMotion);
    }
}
```

**4단계: UX 개선**
```javascript
// QR 스캔 후 자동으로 안내 표시
sdk.on('connected', () => {
    // iOS 감지
    const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);

    if (isIOS) {
        showMessage('센서 시작 버튼을 눌러주세요. (iOS 권한 필요)');
    } else {
        // Android는 자동 시작
        collector.start();
    }
});
```

**결과**:
- iOS 센서 연결 성공률: 15% → **98%**
- 사용자 이탈률: 40% → **5%**
- 1-star 리뷰: 8건 → **0건**

**교훈**:
- 플랫폼별 차이를 간과하지 말 것
- 공식 문서를 꼼꼼히 읽을 것
- UX를 고려한 에러 처리 중요"

**추가 설명 팁**:
- 디버깅 과정 상세히 설명 (console.log, 실제 기기 테스트)
- 비슷한 문제 겪은 개발자들과 공유
- Stack Overflow, GitHub Issues 참고

---

### Q8.2: 프로젝트 중 실패한 경험과 배운 점은?

**모범 답변**:

"**초기에 GPT-4 Turbo로 게임 생성을 시도했다가 실패**했습니다.

**실패한 시도**:
- GPT-4 Turbo: 최대 출력 4,096 토큰 (약 3,000자)
- 평균 게임: 1,500줄, 약 120,000자
- → 5번 나눠서 생성 필요

**문제점**:

**1. 일관성 부족**
```javascript
// 1차 생성 (0-300줄)
const part1 = await gpt4('게임의 시작 부분 생성');
// 변수명: playerX, playerY

// 2차 생성 (300-600줄)
const part2 = await gpt4('게임의 중간 부분 생성');
// 변수명: ballX, ballY  // ❌ 이름 다름!

// 3차 생성 (600-900줄)
const part3 = await gpt4('게임의 후반 부분 생성');
// 함수명: updateGame()  // 이미 part1에서 정의됨 → 충돌

// → 통합 시 에러 발생
```

**2. 비용 증가**
```javascript
// 5번 요청
const totalCost = $0.10 * 5 = $0.50 / 게임

// vs Claude Sonnet 4.5 (1번)
const cost = $0.165 / 게임

// 3배 비용
```

**3. 속도 저하**
```javascript
// 5번 요청 (순차)
const time = 25초 * 5 = 125초

// vs Claude (1번)
const time = 38초

// 3배 느림
```

**결정적 문제: 통합 작업**
```javascript
// 5개 부분을 합치는 추가 작업 필요
const fullCode = part1 + part2 + part3 + part4 + part5;

// → 중복 정의, 변수명 충돌 수동 수정
// → 평균 30분 추가 소요
```

**배운 점**:

**1. 적절한 도구 선택의 중요성**
- GPT-4는 대화에 강함, 긴 코드 생성에는 부적합
- Claude Sonnet 4.5의 64K 토큰이 게임 생성에 최적
- **"Right tool for the right job"**

**2. 초기 기술 검증의 중요성**
- 프로토타입으로 먼저 테스트
- 3개 AI 모델(GPT-4, Gemini, Claude) 비교 테스트 후 결정
- 시간: 1주일 소요했지만 후에 3개월 절약

**3. 비용 계산**
```javascript
// GPT-4로 100개 게임 생성 시
const cost = $0.50 * 100 = $50

// Claude Sonnet 4.5로 100개 게임 생성 시
const cost = $0.165 * 100 = $16.50

// 절감: $33.50 (67%)
```

**전환 후 성과**:
- 생성 성공률: 60% → **93.3%**
- 평균 생성 시간: 125초 → **38초**
- 품질 점수: 85점 → **97.5점**
- 비용: $0.50 → **$0.165**"

**추가 설명 팁**:
- 실패를 숨기지 않고 배운 점 강조
- 데이터 기반 의사결정 (3개 모델 비교)
- 프로토타입의 중요성

---

## 9. 확장성 및 개선 방향

### Q9.1: 이 시스템을 1000명 동시 사용자에게 서비스하려면?

**모범 답변**:

"3가지 주요 병목을 해결해야 합니다: **Claude API 비용**, **WebSocket 연결**, **DB 성능**.

**1. Claude API 비용 최적화**
```javascript
// 현재: 사용자당 게임 1개 생성 시
const costPerUser = $0.165;
const totalCost = $0.165 * 1000 = $165 / 시간

// 문제: 시간당 $165는 과도함

// 해결: 캐싱 + 추천 시스템
const gameTemplates = [
    { id: 'tilt-maze-1', cached: true },
    { id: 'shake-catch-2', cached: true },
    // ...
];

// 사용자가 유사한 게임 요청 시 캐시 활용
if (similarity > 0.9) {
    return templates.find(t => t.similarity === max);
    // 비용: $0 (캐시 사용)
} else {
    return await generateNewGame(userInput);
    // 비용: $0.165
}

// 캐시 히트율 70% 가정
const avgCost = ($0.165 * 0.3) + ($0 * 0.7) = $0.0495
const totalCost = $0.0495 * 1000 = $49.50 / 시간

// 70% 비용 절감
```

**2. WebSocket 확장 (Redis Pub/Sub)**
```javascript
// 현재: 단일 서버, 메모리 기반 세션
const sessions = new Map();

// 문제: 서버 1대 제한, 최대 ~500 동시 연결

// 해결: Redis Pub/Sub + 다중 서버
const redis = new Redis();

// 서버 A
socket.on('sensor-data', async (data) => {
    // Redis에 발행
    await redis.publish(`session:${sessionCode}`, JSON.stringify(data));
});

// 서버 B
redis.subscribe(`session:${sessionCode}`);
redis.on('message', (channel, message) => {
    // 구독자에게 전송
    io.to(sessionCode).emit('sensor-update', JSON.parse(message));
});

// 여러 서버 인스턴스 배포 가능
// Load Balancer로 분산
```

**3. DB 성능 (Connection Pooling + Read Replica)**
```javascript
// 현재: 직접 연결
const supabase = createClient(url, key);

// 문제: 동시 쿼리 제한 (~100)

// 해결: Connection Pooling
const pool = new Pool({
    connectionString: DATABASE_URL,
    max: 200,  // 최대 200 연결
    idleTimeoutMillis: 30000
});

// Read Replica (읽기 부하 분산)
const readReplica = new Pool({
    connectionString: READ_REPLICA_URL,
    max: 300
});

// 쓰기: 마스터
await pool.query('INSERT INTO ...');

// 읽기: 레플리카
await readReplica.query('SELECT * FROM ...');
```

**4. pgvector 확장 (HNSW 인덱스)**
```sql
-- 현재: IVFFlat (500개 문서, 45ms)
CREATE INDEX USING ivfflat ... WITH (lists = 100);

-- 문제: 10,000개 이상 시 느려짐

-- 해결: HNSW 인덱스 (Hierarchical Navigable Small World)
CREATE INDEX game_knowledge_embedding_idx
ON game_knowledge
USING hnsw (embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64);

-- 성능: 100,000개 문서에서도 20ms 유지
```

**5. CDN + 파일 스토리지**
```javascript
// 현재: 서버에서 직접 게임 HTML 서빙
app.get('/games/:gameId.html', (req, res) => {
    res.sendFile(path.join(__dirname, 'public/games', req.params.gameId + '.html'));
});

// 문제: 서버 대역폭 부담

// 해결: S3 + CloudFront
const s3 = new S3Client();

// 게임 업로드
await s3.putObject({
    Bucket: 'sensor-games',
    Key: `games/${gameId}.html`,
    Body: gameCode
});

// CloudFront URL 반환
const url = `https://d123.cloudfront.net/games/${gameId}.html`;
// → CDN에서 직접 서빙, 서버 부하 감소
```

**예상 인프라 비용 (1000명)**:
- Supabase Pro: $25/월
- Redis (Upstash): $10/월
- S3 + CloudFront: $20/월
- Load Balancer: $30/월
- EC2 (3대): $150/월
- **총 비용: $235/월** (사용자당 $0.235)

**성능 목표**:
- 동시 사용자: **1000명**
- 평균 응답 시간: **< 100ms**
- 센서 지연: **< 30ms**
- 게임 생성 시간: **< 45초**"

**추가 설명 팁**:
- 실제 스케일링 경험 있다면 언급
- AWS Well-Architected Framework 참고
- 병목 지점 파악 방법 (프로파일링, 모니터링)

---

### Q9.2: 향후 개선 계획은 무엇인가요?

**모범 답변**:

"4가지 방향으로 개선하고 싶습니다.

**1. 멀티모달 게임 생성 (이미지 → 게임)**
```javascript
// 사용자가 손그림 업로드
const sketch = uploadImage('maze-sketch.png');

// GPT-4 Vision으로 이미지 분석
const description = await openai.chat.completions.create({
    model: 'gpt-4-vision-preview',
    messages: [{
        role: 'user',
        content: [
            { type: 'text', text: '이 미로 이미지를 게임으로 만들어주세요.' },
            { type: 'image_url', image_url: { url: sketch } }
        ]
    }]
});

// Claude로 게임 생성
const game = await generateGame(description);

// → 손그림 → 게임 (30초)
```

**2. AI 게임 디자이너 (반복 개선)**
```javascript
// 사용자: "더 어렵게 해주세요"
const feedback = '더 어렵게';

// GameMaintenanceManager 확장
await maintenanceManager.improveGameplay(gameId, feedback);

// Claude AI가 난이도 조절
// → v1.2 (난이도: medium → hard)

// 여러 번 반복 가능
```

**3. 게임 애널리틱스 (데이터 기반 개선)**
```javascript
// 센서 데이터 일부 저장 (사용자 동의 하에)
const analytics = {
    gameId: 'tilt-maze-v1',
    playTime: 180,  // 초
    attempts: 5,
    completed: true,
    avgTilt: { x: 15, y: 12 }
};

await supabase.from('game_analytics').insert(analytics);

// 데이터 분석
const insights = await analyzeGameplay('tilt-maze-v1');
// → "사용자들이 평균 5번 시도, 3분 플레이"
// → "최적 난이도: medium"

// AI에게 피드백
const improved = await claude.improveGame(gameCode, insights);
```

**4. 소셜 기능 (게임 공유, 리더보드)**
```javascript
// 게임 공유
const shareUrl = await createShareableLink(gameId);
// → https://sensorgames.com/play/tilt-maze-v1

// 리더보드
const leaderboard = await supabase
    .from('game_scores')
    .select('*')
    .eq('game_id', gameId)
    .order('score', { ascending: false })
    .limit(10);

// 친구 초대
await inviteFriend(email, gameId);
```

**5. 크로스 플랫폼 (PWA, 네이티브 앱)**
```javascript
// PWA (Progressive Web App)
// manifest.json
{
  "name": "Sensor Game Hub",
  "short_name": "SensorGames",
  "start_url": "/",
  "display": "standalone",
  "icons": [ /* ... */ ]
}

// Service Worker (오프라인 지원)
self.addEventListener('fetch', (event) => {
    event.respondWith(
        caches.match(event.request)
            .then(response => response || fetch(event.request))
    );
});

// 네이티브 앱 (React Native)
// → 더 나은 센서 접근, 앱스토어 배포
```

**우선순위**:
1. **멀티모달 게임 생성** (3개월)
2. **게임 애널리틱스** (1개월)
3. **소셜 기능** (2개월)
4. **PWA** (2주)
5. **네이티브 앱** (6개월)

**예상 효과**:
- 사용자 증가: **5배**
- 재방문율: **70% → 90%**
- 평균 체류 시간: **10분 → 30분**"

**추가 설명 팁**:
- 구체적인 타임라인 제시
- 우선순위 결정 이유 설명
- 비즈니스 임팩트 언급

---

## 10. 협업 및 의사결정

### Q10.1: 기술 스택을 결정할 때 어떤 과정을 거쳤나요?

**모범 답변**:

"**프로토타입 기반 비교 → 데이터 수집 → 의사결정** 과정을 거쳤습니다.

**예시: AI 모델 선택**

**1단계: 후보 선정 (요구사항 기반)**
```
요구사항:
- 1500줄 코드 생성 가능
- 높은 품질 (SessionSDK 통합)
- 합리적 비용

후보:
- GPT-4 Turbo
- Gemini 1.5 Pro
- Claude Sonnet 3.5
- Claude Sonnet 4.5
```

**2단계: 프로토타입 개발 (1주일)**
```javascript
// 각 모델로 동일한 게임 3개 생성
const testGames = [
    '기울이면 공이 움직이는 미로 게임',
    '흔들면 아이템이 떨어지는 캐치 게임',
    '회전으로 우주선을 조종하는 슈팅 게임'
];

for (const model of models) {
    for (const game of testGames) {
        const result = await generateGame(model, game);
        results.push({ model, game, result });
    }
}
```

**3단계: 정량 평가**
```javascript
// 평가 지표
const metrics = {
    quality: 0,      // GameValidator 점수
    time: 0,         // 생성 시간
    cost: 0,         // 비용
    success: 0       // 성공 여부 (작동함)
};

// 결과
const comparison = [
    { model: 'GPT-4 Turbo', quality: 85, time: 125, cost: 0.50, success: 2/3 },
    { model: 'Gemini 1.5 Pro', quality: 80, time: 95, cost: 0.35, success: 2/3 },
    { model: 'Claude Sonnet 3.5', quality: 92, time: 90, cost: 0.30, success: 3/3 },
    { model: 'Claude Sonnet 4.5', quality: 98, time: 38, cost: 0.165, success: 3/3 }
];
```

**4단계: 종합 평가 (가중치)**
```javascript
// 가중치 설정
const weights = {
    quality: 0.4,    // 품질이 가장 중요
    time: 0.3,       // 속도도 중요
    cost: 0.2,       // 비용
    success: 0.1     // 성공률
};

// 정규화 및 점수 계산
const scores = comparison.map(model => {
    return (
        normalize(model.quality) * weights.quality +
        normalize(100 - model.time) * weights.time +  // 시간은 낮을수록 좋음
        normalize(1 - model.cost) * weights.cost +
        model.success * weights.success
    );
});

// 결과:
// Claude Sonnet 4.5: 0.92
// Claude Sonnet 3.5: 0.75
// GPT-4 Turbo: 0.58
// Gemini 1.5 Pro: 0.55
```

**5단계: 의사결정**
```
선택: Claude Sonnet 4.5

이유:
1. 가장 높은 종합 점수 (0.92)
2. 품질 최고 (98점)
3. 속도 최고 (38초)
4. 비용 최저 ($0.165)
5. 성공률 100% (3/3)

Trade-off:
- 단점: 없음 (모든 면에서 우수)
- 리스크: Anthropic API 장애 시 대체 불가
  → 해결: GPT-4를 백업으로 준비
```

**6단계: 검증 (추가 테스트)**
```javascript
// 30개 게임으로 재검증
const validation = await generateGames(30, 'claude-sonnet-4-5');

const results = {
    avgQuality: 97.5,
    avgTime: 38,
    avgCost: 0.165,
    successRate: 93.3%  // 28/30
};

// ✅ 프로토타입 결과와 일치
// → 최종 결정 확정
```

**교훈**:
- **데이터 기반 의사결정**: 주관적 판단 배제
- **프로토타입 필수**: 실제로 테스트해봐야 알 수 있음
- **명확한 지표**: 무엇을 측정할지 미리 정의
- **검증**: 결정 후 다시 한 번 확인"

**추가 설명 팁**:
- 의사결정 프레임워크 (예: DACI, RACI)
- A/B 테스트 경험
- 실패한 선택 및 피벗 경험

---

### Q10.2: 프로젝트 일정 관리는 어떻게 했나요?

**모범 답변**:

"**Agile 스프린트 방식**으로 3개월 프로젝트를 관리했습니다.

**전체 타임라인 (12주)**:

**Week 1-2: 기술 검증 및 프로토타입**
```
목표: 핵심 기능 프로토타입
- Claude API 테스트 (GPT-4, Gemini 비교)
- Supabase 설정
- 기본 게임 1개 수동 생성
- 센서 연동 테스트

결과:
✅ Claude Sonnet 4.5 선택
✅ Supabase 설정 완료
✅ 센서 연동 성공
❌ iOS 권한 문제 발견 (해결: Week 3)
```

**Week 3-4: 핵심 기능 개발**
```
목표: InteractiveGameGenerator v1.0
- 5단계 생성 프로세스 구현
- SessionManager 개발
- SessionSDK 클라이언트 라이브러리

결과:
✅ 게임 생성 성공 (품질 85점)
✅ 세션 관리 완료
⚠️ 생성 시간 느림 (52초) → 개선 필요
```

**Week 5-6: RAG 시스템 도입**
```
목표: 품질 및 비용 개선
- DocumentEmbedder 개발
- Langchain 통합
- pgvector 설정

결과:
✅ 품질 향상 (85 → 97.5점)
✅ 비용 절감 (79%)
✅ 속도 개선 (52초 → 38초)
```

**Week 7-8: 유지보수 시스템**
```
목표: GameMaintenanceManager
- 버그 수정 자동화
- 기능 추가 자동화
- 버전 관리 시스템

결과:
✅ 자동 버그 수정 (평균 45초)
✅ Semantic Versioning
✅ DB 버전 이력 저장
```

**Week 9-10: 권한 관리 및 보안**
```
목표: 안전한 멀티 사용자 지원
- RLS 정책 구현
- 미들웨어 검증
- creator_id 추가

결과:
✅ RLS 정책 완료
✅ JWT 인증
✅ 보안 테스트 통과 (100%)
```

**Week 11-12: 테스트 및 문서화**
```
목표: 프로덕션 준비
- 19개 게임 생성 테스트
- 성능 최적화
- 문서 작성

결과:
✅ 19개 게임 모두 작동
✅ 평균 품질 97.5점
✅ 문서화 완료
```

**일정 관리 도구**:
- **GitHub Projects**: 칸반 보드
- **Issues**: 작업 단위 추적
- **Milestones**: 주차별 목표

**주간 프로세스**:
```
월요일:
- 주간 목표 설정
- 작업 우선순위 지정

화-목:
- 개발 및 테스트
- Daily Standup (자가 점검)

금요일:
- 주간 회고
- 다음 주 계획
- 데모 (스스로 테스트)

주말:
- 선택적 학습 및 리서치
```

**리스크 관리**:
```javascript
// 주요 리스크 및 대응
const risks = [
    {
        risk: 'Claude API 장애',
        impact: 'High',
        probability: 'Low',
        mitigation: 'GPT-4를 백업으로 준비'
    },
    {
        risk: 'iOS 센서 권한 문제',
        impact: 'High',
        probability: 'High',
        mitigation: '빠른 발견 및 해결 (Week 3)'
    },
    {
        risk: 'pgvector 성능 부족',
        impact: 'Medium',
        probability: 'Medium',
        mitigation: '프로토타입으로 미리 테스트'
    }
];
```

**실제 일정 vs 계획**:
- 계획: 12주
- 실제: 13주
- 지연 이유: iOS 권한 문제 (1주 추가)
- 조치: Week 11-12 병행 작업으로 만회"

**추가 설명 팁**:
- Agile vs Waterfall 차이
- 일정 지연 시 대응 방법
- 우선순위 결정 기준 (MoSCoW 등)

---

## 마무리

이 문서는 **Sensor Game Hub** 프로젝트에 대한 면접 질문 대비 자료입니다. 각 질문에 대한 모범 답변은 다음을 포함합니다:

1. **구체적 수치**: 성능, 비용, 시간 등 정량적 데이터
2. **코드 예시**: 실제 구현 내용
3. **Before/After 비교**: 개선 효과 명확히 제시
4. **의사결정 과정**: 왜 그렇게 결정했는지
5. **실패 및 교훈**: 문제 해결 능력

**면접 팁**:
- 질문에 정확히 답하되, 너무 길지 않게 (2-3분)
- 구체적 수치 강조
- STAR 기법 (Situation, Task, Action, Result)
- 겸손하되 자신감 있게
- 추가 질문 유도 ("더 자세히 설명해드릴까요?")

**준비 사항**:
- 화이트보드에 아키텍처 그릴 준비
- 주요 코드 스니펫 암기
- 프로젝트 데모 가능한 환경
- GitHub 레포지토리 정리

**행운을 빕니다! 🚀**

---

**참고 문서**:
- [01_프로젝트_개요_및_아키텍처.md](./01_프로젝트_개요_및_아키텍처.md)
- [03_AI_시스템_상세분석.md](./03_AI_시스템_상세분석.md)
- [07_기술적_의사결정.md](./07_기술적_의사결정.md)
