# Sensor Game Hub - 시스템 플로우 상세 분석

> 주요 프로세스의 단계별 실행 흐름과 데이터 흐름 분석
>
> 작성일: 2025-10-17 | 버전: v6.1

---

## 목차

1. [AI 게임 생성 플로우](#1-ai-게임-생성-플로우)
2. [센서 게임 플레이 플로우](#2-센서-게임-플레이-플로우)
3. [유지보수 플로우](#3-유지보수-플로우)
4. [RAG 검색 플로우](#4-rag-검색-플로우)
5. [WebSocket 통신 플로우](#5-websocket-통신-플로우)
6. [권한 검증 플로우](#6-권한-검증-플로우)
7. [세션 관리 플로우](#7-세션-관리-플로우)

---

## 1. AI 게임 생성 플로우

### 1.1 전체 프로세스 개요

```
사용자 아이디어 입력
    ↓
세션 생성 및 초기화
    ↓
5단계 생성 프로세스
    ↓ (0-20%)   Stage 1: 게임 아이디어 분석
    ↓ (20-40%)  Stage 2: RAG 문서 검색
    ↓ (40-80%)  Stage 3: Claude AI 코드 생성
    ↓ (80-90%)  Stage 4: 코드 검증 (최소 95점)
    ↓ (90-100%) Stage 5: 파일 저장 및 DB 등록
    ↓
게임 완성 및 배포
```

### 1.2 Stage 1: 게임 아이디어 분석 (0-20%)

**목적**: 사용자 입력을 분석하여 게임 장르, 타입, 필수 요소 파악

**실행 위치**: `server/InteractiveGameGenerator.js:357-445`

**상세 단계**:

```javascript
// 1단계: 사용자 메시지 수신
async processInitialStage(session, userMessage, context) {
    console.log(`[Stage 1] 게임 아이디어 분석 시작: "${userMessage}"`);

    // 1.1 진행률 업데이트 (0%)
    this.updateProgress(session.id, 0, 'idea-analysis');

    // 1.2 장르 분류 (GenreClassifier 사용)
    const genreAnalysis = await this.genreClassifier.classifyGameIdea(userMessage);
    console.log('[Stage 1] 장르 분석 결과:', genreAnalysis);

    // 1.3 세션 컨텍스트 업데이트
    session.context.genre = genreAnalysis.genre;        // 예: 'action', 'puzzle'
    session.context.gameType = genreAnalysis.gameType;  // 예: 'solo', 'dual'
    session.context.mainMechanics = genreAnalysis.mechanics; // 예: ['tilt', 'shake']

    // 1.4 진행률 업데이트 (20%)
    this.updateProgress(session.id, 20, 'idea-analysis-complete');

    // 1.5 다음 단계 질문 생성
    const nextQuestion = this.generateContextualQuestion(session.context);

    return {
        message: `분석 완료! ${genreAnalysis.genre} 장르의 ${genreAnalysis.gameType} 게임으로 파악했습니다.\n\n${nextQuestion}`,
        stage: 'clarification',
        progress: 20
    };
}
```

**데이터 흐름**:

```
사용자: "기울이면 공이 움직이는 미로 게임"
    ↓
GenreClassifier 분석
    ↓
{
    genre: 'puzzle',
    gameType: 'solo',
    mechanics: ['tilt', 'maze-navigation'],
    complexity: 'medium'
}
    ↓
세션 컨텍스트 저장
    ↓
클라이언트에 진행률 전송 (20%)
```

### 1.3 Stage 2: RAG 문서 검색 (20-40%)

**목적**: 유사한 게임 예제 및 센서 활용 패턴 검색

**실행 위치**: `server/InteractiveGameGenerator.js:507-612`

**상세 단계**:

```javascript
// 2단계: RAG 기반 컨텍스트 검색
async getRelevantContext(userMessage) {
    console.log('[Stage 2] RAG 문서 검색 시작');

    // 2.1 진행률 업데이트 (20%)
    this.updateProgress(session.id, 20, 'rag-search-start');

    // 2.2 검색 쿼리 최적화
    const optimizedQuery = this.optimizeSearchQuery(userMessage, session.context);
    console.log('[Stage 2] 최적화된 쿼리:', optimizedQuery);
    // 예: "tilt sensor maze game puzzle solo examples"

    // 2.3 벡터 유사도 검색 (OpenAI Embeddings)
    const results = await this.vectorStore.similaritySearch(
        optimizedQuery,
        this.config.ragTopK  // 5개 문서
    );

    console.log(`[Stage 2] 검색 완료: ${results.length}개 문서 발견`);

    // 2.4 검색 결과 필터링 (유사도 0.7 이상)
    const filteredResults = results.filter(doc =>
        doc.metadata.similarity >= this.config.ragSimilarityThreshold
    );

    // 2.5 진행률 업데이트 (40%)
    this.updateProgress(session.id, 40, 'rag-search-complete');

    // 2.6 컨텍스트 문자열 생성
    const contextString = filteredResults.map(doc => `
=== 예제 ${doc.metadata.gameId} ===
장르: ${doc.metadata.genre}
센서: ${doc.metadata.sensors.join(', ')}
핵심 코드:
${doc.pageContent}
    `).join('\n\n');

    return contextString;
}
```

**벡터 검색 과정**:

```
사용자 메시지
    ↓
OpenAI text-embedding-3-small
    ↓
1536차원 벡터 생성
    ↓
Supabase pgvector 코사인 유사도 검색
    ↓
SELECT * FROM game_knowledge
ORDER BY embedding <=> $1
LIMIT 5
    ↓
Top-5 유사 문서 반환
    ↓
유사도 0.7 이상 필터링
    ↓
컨텍스트 문자열 생성
```

### 1.4 Stage 3: Claude AI 코드 생성 (40-80%)

**목적**: Claude Sonnet 4.5를 사용하여 완전한 게임 코드 생성

**실행 위치**: `server/InteractiveGameGenerator.js:614-768`

**상세 단계**:

```javascript
// 3단계: Claude AI 코드 생성
async generateGameCode(requirements, context) {
    console.log('[Stage 3] Claude AI 코드 생성 시작');

    // 3.1 진행률 업데이트 (40%)
    this.updateProgress(session.id, 40, 'code-generation-start');

    // 3.2 프롬프트 구성
    const systemPrompt = `당신은 모바일 센서 게임 개발 전문가입니다.
SessionSDK를 사용하여 완전히 작동하는 HTML5 게임을 생성하세요.

필수 요구사항:
1. HTML5 Canvas 기반 렌더링
2. SessionSDK 통합 (QR 코드, 센서 연결)
3. DeviceMotion/Orientation API 활용
4. 반응형 디자인
5. 에러 처리 및 로깅

참고할 예제 코드:
${context}

게임 템플릿:
${this.gameTemplate}`;

    const userPrompt = `다음 요구사항에 맞는 게임을 생성하세요:

제목: ${requirements.title}
장르: ${requirements.genre}
게임 타입: ${requirements.gameType}
주요 메커니즘: ${requirements.mechanics.join(', ')}
난이도: ${requirements.difficulty}

상세 설명:
${requirements.description}

반드시 완전히 작동하는 HTML 파일을 생성하세요.`;

    // 3.3 Claude API 호출
    const response = await this.anthropicClient.messages.create({
        model: 'claude-sonnet-4-5-20250929',
        max_tokens: 64000,  // 64K 토큰
        temperature: 0.3,   // 낮은 temperature로 일관성 확보
        system: systemPrompt,
        messages: [{
            role: 'user',
            content: userPrompt
        }]
    });

    console.log(`[Stage 3] Claude 응답 수신: ${response.content[0].text.length}자`);

    // 3.4 진행률 업데이트 (80%)
    this.updateProgress(session.id, 80, 'code-generation-complete');

    // 3.5 HTML 코드 추출
    const generatedCode = this.extractHTMLCode(response.content[0].text);

    return generatedCode;
}
```

**Claude API 통신**:

```
프롬프트 구성 (시스템 + 사용자)
    ↓
Anthropic API 호출
POST https://api.anthropic.com/v1/messages
    ↓
Claude Sonnet 4.5 처리 (최대 64K 토큰)
    ↓
응답 수신 (평균 20-40초)
    ↓
HTML 코드 추출 (```html ... ``` 파싱)
    ↓
코드 검증 단계로 전달
```

### 1.5 Stage 4: 코드 검증 (80-90%)

**목적**: GameValidator로 코드 품질 검증 (최소 95점)

**실행 위치**: `server/InteractiveGameGenerator.js:770-885`

**상세 단계**:

```javascript
// 4단계: 코드 검증
async validateGeneratedCode(code, requirements) {
    console.log('[Stage 4] 코드 검증 시작');

    // 4.1 진행률 업데이트 (80%)
    this.updateProgress(session.id, 80, 'validation-start');

    // 4.2 GameValidator 실행
    const validationResult = await this.gameValidator.validateGame(code, {
        gameType: requirements.gameType,
        expectedSensors: requirements.mechanics
    });

    console.log('[Stage 4] 검증 결과:', validationResult);

    // 4.3 점수 확인 (최소 95점)
    if (validationResult.qualityScore < this.config.minQualityScore) {
        console.warn(`[Stage 4] 품질 점수 부족: ${validationResult.qualityScore}/100`);

        // 4.3.1 재생성 또는 수정
        if (this.retryCount < this.maxRetries) {
            this.retryCount++;
            const fixedCode = await this.fixCodeIssues(code, validationResult.issues);
            return this.validateGeneratedCode(fixedCode, requirements);
        } else {
            throw new Error('코드 품질 기준을 충족하지 못했습니다.');
        }
    }

    // 4.4 진행률 업데이트 (90%)
    this.updateProgress(session.id, 90, 'validation-complete');

    return {
        isValid: true,
        qualityScore: validationResult.qualityScore,
        code: code
    };
}
```

**검증 항목**:

```
1. 필수 요소 검사 (40점)
   - SessionSDK 초기화: 10점
   - QR 코드 생성: 10점
   - 센서 데이터 처리: 10점
   - 게임 로직 구현: 10점

2. 코드 품질 (30점)
   - 에러 처리: 10점
   - 주석 및 문서화: 10점
   - 코드 구조: 10점

3. 보안 및 성능 (30점)
   - XSS 방지: 10점
   - 메모리 관리: 10점
   - 최적화: 10점

총점: 100점 (최소 95점 통과)
```

### 1.6 Stage 5: 파일 저장 및 DB 등록 (90-100%)

**목적**: 검증된 게임 코드를 파일 시스템과 DB에 저장

**실행 위치**: `server/InteractiveGameGenerator.js:887-1024`

**상세 단계**:

```javascript
// 5단계: 파일 저장 및 등록
async finalizeGame(session, validatedCode, metadata) {
    console.log('[Stage 5] 게임 완성 단계 시작');

    // 5.1 진행률 업데이트 (90%)
    this.updateProgress(session.id, 90, 'finalization-start');

    // 5.2 게임 ID 생성
    const gameId = this.generateGameId(metadata.title);
    console.log(`[Stage 5] 게임 ID: ${gameId}`);

    // 5.3 파일 저장
    const filePath = path.join(
        __dirname,
        '../public/games',
        `${gameId}.html`
    );

    await fs.promises.writeFile(filePath, validatedCode, 'utf8');
    console.log(`[Stage 5] 파일 저장 완료: ${filePath}`);

    // 5.4 Supabase DB 등록
    const { data: gameRecord, error } = await this.supabase
        .from('generated_games')
        .insert({
            game_id: gameId,
            title: metadata.title,
            description: metadata.description,
            game_type: metadata.gameType,
            creator_id: session.userId,  // 권한 관리
            metadata: {
                genre: metadata.genre,
                mechanics: metadata.mechanics,
                difficulty: metadata.difficulty,
                qualityScore: metadata.qualityScore,
                createdBy: 'InteractiveGameGenerator v2.0'
            }
        })
        .select()
        .single();

    if (error) {
        throw new Error(`DB 등록 실패: ${error.message}`);
    }

    console.log('[Stage 5] DB 등록 완료:', gameRecord.id);

    // 5.5 GameMaintenanceManager에 자동 등록 (v1.0)
    await this.maintenanceManager.registerNewGame(gameId, {
        version: 'v1.0',
        filePath: filePath,
        metadata: metadata
    });

    console.log('[Stage 5] 유지보수 시스템 등록 완료');

    // 5.6 진행률 업데이트 (100%)
    this.updateProgress(session.id, 100, 'complete');

    // 5.7 세션 정리
    this.sessionManager.cleanupSession(session.id);

    return {
        gameId: gameId,
        url: `/games/${gameId}.html`,
        title: metadata.title,
        completedAt: new Date().toISOString()
    };
}
```

**파일 시스템 및 DB 저장**:

```
검증된 HTML 코드
    ↓
게임 ID 생성 (제목 기반 slug)
    ↓
파일 저장
/public/games/{gameId}.html
    ↓
Supabase INSERT
generated_games 테이블
    ↓
유지보수 시스템 등록
game_versions 테이블 (v1.0)
    ↓
세션 정리
    ↓
클라이언트에 완료 알림
```

---

## 2. 센서 게임 플레이 플로우

### 2.1 전체 프로세스 개요

```
게임 페이지 접속
    ↓
SessionSDK 초기화
    ↓
세션 생성 (WebSocket)
    ↓
QR 코드 생성 및 표시
    ↓
모바일에서 QR 스캔
    ↓
센서 페이지 접속 (sensor.html)
    ↓
센서 연결 (WebSocket)
    ↓
권한 요청 (DeviceMotion)
    ↓
센서 데이터 수집 (50ms 간격)
    ↓
WebSocket으로 전송
    ↓
게임 페이지에서 수신
    ↓
게임 로직 적용
    ↓
Canvas 렌더링
```

### 2.2 세션 생성 및 QR 코드 표시

**클라이언트 측 (게임 페이지)**:

```javascript
// SessionSDK 초기화
const sdk = new SessionSDK({
    gameId: 'tilt-maze-v1',
    gameType: 'solo',
    serverUrl: window.location.origin,
    debug: true
});

// 서버 연결 대기
sdk.on('connected', async () => {
    console.log('[Game] 서버 연결 완료');

    // 세션 생성 요청
    const session = await sdk.createSession();
    console.log('[Game] 세션 생성됨:', session.sessionCode);

    // QR 코드 생성
    const qrCode = await QRCodeGenerator.generateElement(
        `${window.location.origin}/sensor.html?code=${session.sessionCode}`,
        200  // 크기
    );

    // DOM에 추가
    document.getElementById('qr-container').appendChild(qrCode);

    // 안내 메시지 표시
    document.getElementById('instruction').textContent =
        `QR 코드를 스캔하여 센서를 연결하세요 (코드: ${session.sessionCode})`;
});

// 센서 연결 이벤트
sdk.on('sensor-connected', (event) => {
    const { sensorId } = event.detail || event;
    console.log('[Game] 센서 연결됨:', sensorId);

    // UI 업데이트
    document.getElementById('status').textContent = '센서 연결됨 - 게임 시작!';
    document.getElementById('qr-container').style.display = 'none';

    // 게임 시작
    startGame();
});
```

**서버 측 (WebSocket 핸들러)**:

```javascript
// server/index.js:142-187
socket.on('create-session', async (data) => {
    console.log('[Server] 세션 생성 요청:', data);

    // SessionManager로 세션 생성
    const session = await sessionManager.createSession({
        gameId: data.gameId,
        gameType: data.gameType,
        maxPlayers: data.gameType === 'solo' ? 1 : data.gameType === 'dual' ? 2 : 4
    });

    // 소켓을 세션 룸에 조인
    socket.join(`session-${session.sessionCode}`);

    // 클라이언트에 세션 정보 전송
    socket.emit('session-created', {
        sessionCode: session.sessionCode,
        gameId: session.gameId,
        gameType: session.gameType,
        createdAt: session.createdAt
    });

    console.log(`[Server] 세션 생성 완료: ${session.sessionCode}`);
});
```

### 2.3 센서 연결 및 데이터 전송

**모바일 센서 페이지 (sensor.html)**:

```javascript
// 1. URL에서 세션 코드 추출
const urlParams = new URLSearchParams(window.location.search);
const sessionCode = urlParams.get('code');

if (!sessionCode) {
    alert('유효한 QR 코드를 스캔해주세요.');
    throw new Error('세션 코드가 없습니다.');
}

// 2. SessionSDK 초기화
const sdk = new SessionSDK({
    gameId: 'sensor-client',
    gameType: 'solo',
    serverUrl: window.location.origin,
    debug: true
});

// 3. 서버 연결 후 센서 연결
sdk.on('connected', async () => {
    console.log('[Sensor] 서버 연결 완료');

    // 센서 연결 요청
    await sdk.connectSensor(sessionCode);

    // 센서 권한 요청 (iOS 13+)
    if (typeof DeviceMotionEvent.requestPermission === 'function') {
        const permission = await DeviceMotionEvent.requestPermission();
        if (permission !== 'granted') {
            alert('센서 권한이 필요합니다.');
            return;
        }
    }

    // SensorCollector 시작
    const collector = new SensorCollector({
        sampleRate: 50  // 50ms 간격 (20Hz)
    });

    collector.start();

    // 센서 데이터 수집 이벤트
    collector.on('data', (sensorData) => {
        // WebSocket으로 전송
        sdk.sendSensorData(sensorData);
    });
});
```

**센서 데이터 구조**:

```javascript
{
    timestamp: 1697500000000,
    data: {
        // 방향 센서 (기울기)
        orientation: {
            alpha: 180.5,   // 나침반 (0-360도)
            beta: 45.2,     // 전후 기울기 (-180~180도)
            gamma: -15.8    // 좌우 기울기 (-90~90도)
        },

        // 가속도 센서
        acceleration: {
            x: 0.5,   // 좌우 (-10 ~ 10 m/s²)
            y: -2.1,  // 상하
            z: 9.8    // 전후
        },

        // 중력 제거 가속도
        accelerationIncludingGravity: {
            x: 0.5,
            y: 7.7,
            z: 9.8
        },

        // 회전 속도
        rotationRate: {
            alpha: 0.1,   // rad/s
            beta: -0.3,
            gamma: 0.0
        }
    }
}
```

### 2.4 게임에서 센서 데이터 처리

**게임 로직 예시 (미로 게임)**:

```javascript
// 센서 데이터 수신 이벤트
sdk.on('sensor-data', (event) => {
    const sensorData = event.detail || event;
    processSensorData(sensorData);
});

function processSensorData(sensorData) {
    const { data } = sensorData;

    // 기울기 값 추출
    const tiltX = data.orientation.gamma;  // 좌우: -90 ~ 90
    const tiltY = data.orientation.beta;   // 전후: -180 ~ 180

    // 게임 오브젝트 이동 (공)
    ball.velocityX += (tiltX / 90) * ball.acceleration;
    ball.velocityY += (tiltY / 180) * ball.acceleration;

    // 최대 속도 제한
    ball.velocityX = Math.max(-ball.maxSpeed, Math.min(ball.maxSpeed, ball.velocityX));
    ball.velocityY = Math.max(-ball.maxSpeed, Math.min(ball.maxSpeed, ball.velocityY));

    // 위치 업데이트
    ball.x += ball.velocityX;
    ball.y += ball.velocityY;

    // 벽 충돌 검사
    checkWallCollision(ball);

    // 목표 지점 도달 검사
    if (checkGoalReached(ball, goal)) {
        gameWon();
    }
}

// 렌더링 루프
function gameLoop() {
    // Canvas 지우기
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 미로 그리기
    drawMaze(maze);

    // 공 그리기
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
    ctx.fillStyle = '#4CAF50';
    ctx.fill();

    // 목표 지점 그리기
    ctx.fillStyle = '#FFD700';
    ctx.fillRect(goal.x, goal.y, goal.width, goal.height);

    // 다음 프레임 요청
    requestAnimationFrame(gameLoop);
}

// 게임 시작
function startGame() {
    gameLoop();
}
```

---

## 3. 유지보수 플로우

### 3.1 버그 수정 플로우

**전체 프로세스**:

```
버그 리포트 접수
    ↓
권한 검증 (본인 또는 admin)
    ↓
현재 게임 코드 읽기
    ↓
버전 백업 (v1.0 → v1.0-backup)
    ↓
Claude AI 버그 분석 및 수정
    ↓
수정된 코드 저장
    ↓
버전 증가 (v1.0 → v1.1)
    ↓
DB 업데이트
    ↓
수정 완료 응답
```

**상세 구현 (GameMaintenanceManager)**:

```javascript
// server/GameMaintenanceManager.js:156-298
async fixBug(gameId, bugDescription, userId) {
    console.log(`[Maintenance] 버그 수정 시작: ${gameId}`);
    console.log(`[Maintenance] 버그 설명: ${bugDescription}`);

    // 1. 권한 검증
    const hasPermission = await this.checkPermission(gameId, userId);
    if (!hasPermission) {
        throw new Error('이 게임을 수정할 권한이 없습니다.');
    }

    // 2. 현재 코드 읽기
    const filePath = path.join(__dirname, '../public/games', `${gameId}.html`);
    const currentCode = await fs.promises.readFile(filePath, 'utf8');
    console.log(`[Maintenance] 현재 코드 읽기 완료: ${currentCode.length}자`);

    // 3. 현재 버전 정보 조회
    const versionInfo = await this.getVersionInfo(gameId);
    console.log(`[Maintenance] 현재 버전: ${versionInfo.current_version}`);

    // 4. 백업 생성
    const backupPath = path.join(
        __dirname,
        '../public/games/backups',
        `${gameId}-${versionInfo.current_version}-backup.html`
    );
    await fs.promises.writeFile(backupPath, currentCode, 'utf8');
    console.log(`[Maintenance] 백업 완료: ${backupPath}`);

    // 5. Claude AI로 버그 수정
    const fixedCode = await this.generateBugFix(currentCode, bugDescription);
    console.log(`[Maintenance] 수정 코드 생성 완료: ${fixedCode.length}자`);

    // 6. 수정된 코드 저장
    await fs.promises.writeFile(filePath, fixedCode, 'utf8');
    console.log('[Maintenance] 수정 코드 저장 완료');

    // 7. 버전 증가 (v1.0 → v1.1)
    const newVersion = this.incrementVersion(versionInfo.current_version, 'patch');
    console.log(`[Maintenance] 새 버전: ${newVersion}`);

    // 8. DB 업데이트
    await this.updateVersionInDB(gameId, newVersion, {
        type: 'bug-fix',
        description: bugDescription,
        fixedAt: new Date().toISOString(),
        fixedBy: userId
    });

    console.log('[Maintenance] 버그 수정 완료');

    return {
        success: true,
        gameId: gameId,
        oldVersion: versionInfo.current_version,
        newVersion: newVersion,
        message: '버그가 성공적으로 수정되었습니다.'
    };
}
```

**Claude AI 버그 수정 프롬프트**:

```javascript
async generateBugFix(currentCode, bugDescription) {
    const prompt = `다음 게임 코드에서 버그를 찾아 수정하세요.

버그 설명:
${bugDescription}

현재 코드:
\`\`\`html
${currentCode}
\`\`\`

요구사항:
1. 버그의 원인을 정확히 파악하세요.
2. 최소한의 수정으로 버그를 해결하세요.
3. 기존 기능이 손상되지 않도록 하세요.
4. 수정된 완전한 HTML 코드를 반환하세요.
5. 주석으로 수정 내용을 명시하세요.`;

    const response = await this.anthropicClient.messages.create({
        model: 'claude-sonnet-4-5-20250929',
        max_tokens: 64000,
        temperature: 0.2,  // 낮은 temperature로 안정성 확보
        messages: [{
            role: 'user',
            content: prompt
        }]
    });

    return this.extractHTMLCode(response.content[0].text);
}
```

### 3.2 기능 추가 플로우

**전체 프로세스**:

```
기능 추가 요청
    ↓
권한 검증
    ↓
현재 코드 읽기
    ↓
버전 백업
    ↓
Claude AI 증분 업데이트
    ↓
기능이 추가된 코드 저장
    ↓
버전 증가 (v1.1 → v1.2)
    ↓
DB 업데이트
    ↓
완료 응답
```

**상세 구현**:

```javascript
// server/GameMaintenanceManager.js:300-442
async addFeature(gameId, featureDescription, userId) {
    console.log(`[Maintenance] 기능 추가 시작: ${gameId}`);
    console.log(`[Maintenance] 기능 설명: ${featureDescription}`);

    // 1-4단계: 버그 수정과 동일 (권한 검증, 코드 읽기, 백업)
    // ...

    // 5. Claude AI로 기능 추가
    const updatedCode = await this.generateFeatureAddition(currentCode, featureDescription);
    console.log(`[Maintenance] 업데이트된 코드 생성 완료: ${updatedCode.length}자`);

    // 6-8단계: 저장, 버전 증가, DB 업데이트
    // ...

    return {
        success: true,
        gameId: gameId,
        oldVersion: versionInfo.current_version,
        newVersion: newVersion,
        message: '기능이 성공적으로 추가되었습니다.'
    };
}
```

**Claude AI 기능 추가 프롬프트**:

```javascript
async generateFeatureAddition(currentCode, featureDescription) {
    const prompt = `다음 게임에 새로운 기능을 추가하세요.

추가할 기능:
${featureDescription}

현재 코드:
\`\`\`html
${currentCode}
\`\`\`

요구사항:
1. 기존 기능을 유지하면서 새 기능을 추가하세요.
2. 코드 구조를 깔끔하게 유지하세요.
3. 새로운 기능에 대한 주석을 추가하세요.
4. 기존 스타일과 일관성을 유지하세요.
5. 완전한 HTML 코드를 반환하세요.`;

    const response = await this.anthropicClient.messages.create({
        model: 'claude-sonnet-4-5-20250929',
        max_tokens: 64000,
        temperature: 0.3,
        messages: [{
            role: 'user',
            content: prompt
        }]
    });

    return this.extractHTMLCode(response.content[0].text);
}
```

### 3.3 버전 관리 시스템

**버전 증가 규칙**:

```javascript
// server/GameMaintenanceManager.js:544-578
incrementVersion(currentVersion, type) {
    // 버전 형식: v1.2.3
    const match = currentVersion.match(/v(\d+)\.(\d+)\.?(\d+)?/);

    if (!match) {
        return 'v1.0';
    }

    let [, major, minor, patch] = match;
    major = parseInt(major);
    minor = parseInt(minor);
    patch = parseInt(patch || 0);

    switch (type) {
        case 'major':   // 대규모 변경
            return `v${major + 1}.0.0`;

        case 'minor':   // 기능 추가
            return `v${major}.${minor + 1}.0`;

        case 'patch':   // 버그 수정
            return `v${major}.${minor}.${patch + 1}`;

        default:
            return `v${major}.${minor + 1}`;
    }
}
```

**DB 버전 업데이트**:

```javascript
async updateVersionInDB(gameId, newVersion, modification) {
    // 1. 기존 버전 정보 조회
    const { data: existingVersion } = await this.supabase
        .from('game_versions')
        .select('*')
        .eq('game_id', gameId)
        .single();

    // 2. modifications 배열에 추가
    const modifications = existingVersion?.modifications || [];
    modifications.push({
        version: newVersion,
        type: modification.type,        // 'bug-fix' or 'feature-add'
        description: modification.description,
        timestamp: modification.fixedAt || modification.addedAt,
        userId: modification.fixedBy || modification.addedBy
    });

    // 3. DB 업데이트
    const { data, error } = await this.supabase
        .from('game_versions')
        .upsert({
            game_id: gameId,
            current_version: newVersion,
            modifications: modifications,
            updated_at: new Date().toISOString()
        })
        .select()
        .single();

    if (error) {
        throw new Error(`버전 업데이트 실패: ${error.message}`);
    }

    return data;
}
```

---

## 4. RAG 검색 플로우

### 4.1 문서 임베딩 프로세스

**초기 설정 시 한 번만 실행**:

```
게임 예제 HTML 파일들
    ↓
DocumentEmbedder 실행
    ↓
HTML 파싱 및 텍스트 추출
    ↓
청크 분할 (1000자 단위)
    ↓
OpenAI Embeddings 생성
    ↓
Supabase game_knowledge 테이블 저장
```

**상세 구현**:

```javascript
// server/utils/DocumentEmbedder.js:45-178
async embedDocuments(sourceDir) {
    console.log(`[Embedder] 문서 임베딩 시작: ${sourceDir}`);

    // 1. HTML 파일 목록 읽기
    const files = await fs.promises.readdir(sourceDir);
    const htmlFiles = files.filter(f => f.endsWith('.html'));
    console.log(`[Embedder] 발견된 파일: ${htmlFiles.length}개`);

    for (const file of htmlFiles) {
        // 2. HTML 파일 읽기
        const content = await fs.promises.readFile(
            path.join(sourceDir, file),
            'utf8'
        );

        // 3. 메타데이터 추출
        const metadata = this.extractMetadata(content);
        console.log(`[Embedder] ${file} 메타데이터:`, metadata);

        // 4. 청크 분할
        const chunks = this.splitIntoChunks(content, {
            chunkSize: 1000,      // 1000자
            chunkOverlap: 200     // 200자 겹침
        });
        console.log(`[Embedder] ${file} 청크: ${chunks.length}개`);

        // 5. 각 청크에 대해 임베딩 생성
        for (let i = 0; i < chunks.length; i++) {
            const chunk = chunks[i];

            // OpenAI Embeddings API 호출
            const embedding = await this.openai.embeddings.create({
                model: 'text-embedding-3-small',
                input: chunk,
                encoding_format: 'float'
            });

            const vector = embedding.data[0].embedding;  // 1536차원

            // Supabase에 저장
            await this.supabase
                .from('game_knowledge')
                .insert({
                    content: chunk,
                    embedding: vector,
                    metadata: {
                        ...metadata,
                        file: file,
                        chunkIndex: i,
                        chunkTotal: chunks.length
                    }
                });

            console.log(`[Embedder] ${file} 청크 ${i+1}/${chunks.length} 임베딩 완료`);
        }
    }

    console.log('[Embedder] 모든 문서 임베딩 완료');
}
```

### 4.2 유사도 검색 프로세스

**검색 실행 시**:

```
사용자 쿼리
    ↓
쿼리 최적화 (키워드 추출)
    ↓
OpenAI Embeddings 생성
    ↓
Supabase pgvector 검색
    ↓
코사인 유사도 계산
    ↓
Top-K 문서 반환
    ↓
유사도 임계값 필터링 (0.7)
    ↓
컨텍스트 문자열 생성
```

**상세 구현**:

```javascript
// server/InteractiveGameGenerator.js:507-612
async getRelevantContext(userMessage) {
    console.log('[RAG] 검색 시작');

    // 1. 쿼리 최적화
    const optimizedQuery = this.optimizeSearchQuery(userMessage, this.context);
    console.log('[RAG] 최적화된 쿼리:', optimizedQuery);
    // 예: "tilt sensor maze game puzzle solo examples"

    // 2. Langchain VectorStore 검색
    const results = await this.vectorStore.similaritySearch(
        optimizedQuery,
        this.config.ragTopK  // 5개
    );

    console.log(`[RAG] 검색 결과: ${results.length}개`);

    // 3. 결과 필터링
    const filteredResults = results.filter(doc => {
        const similarity = doc.metadata.similarity || 0;
        return similarity >= this.config.ragSimilarityThreshold;  // 0.7
    });

    console.log(`[RAG] 필터링 후: ${filteredResults.length}개`);

    // 4. 컨텍스트 문자열 생성
    const contextString = filteredResults.map((doc, index) => `
=== 예제 ${index + 1}: ${doc.metadata.gameId} ===
장르: ${doc.metadata.genre}
게임 타입: ${doc.metadata.gameType}
사용 센서: ${doc.metadata.sensors.join(', ')}

핵심 코드:
${doc.pageContent}
    `).join('\n\n');

    return contextString;
}
```

**Supabase pgvector 검색 SQL**:

```sql
-- Langchain이 내부적으로 실행하는 쿼리
SELECT
    id,
    content,
    metadata,
    1 - (embedding <=> $1::vector) AS similarity
FROM game_knowledge
WHERE 1 - (embedding <=> $1::vector) >= $2
ORDER BY embedding <=> $1::vector
LIMIT $3;

-- 파라미터:
-- $1: 쿼리 임베딩 벡터 (1536차원)
-- $2: 유사도 임계값 (0.7)
-- $3: Top-K (5)

-- <=>: 코사인 거리 연산자
-- 1 - 코사인 거리 = 코사인 유사도
```

---

## 5. WebSocket 통신 플로우

### 5.1 연결 수립

**클라이언트 → 서버**:

```javascript
// SessionSDK 초기화 시
const socket = io(serverUrl, {
    transports: ['websocket', 'polling'],
    reconnection: true,
    reconnectionDelay: 1000,
    reconnectionAttempts: 5
});

socket.on('connect', () => {
    console.log('[WebSocket] 연결 성공:', socket.id);
    this.dispatchEvent(new CustomEvent('connected', {
        detail: { socketId: socket.id }
    }));
});

socket.on('disconnect', (reason) => {
    console.log('[WebSocket] 연결 종료:', reason);

    if (this.config.autoReconnect) {
        setTimeout(() => socket.connect(), 1000);
    }
});
```

**서버 측**:

```javascript
// server/index.js:120-138
io.on('connection', (socket) => {
    console.log(`[WebSocket] 새 클라이언트 연결: ${socket.id}`);

    // 연결 정보 저장
    connectedClients.set(socket.id, {
        connectedAt: new Date(),
        sessionCode: null,
        gameId: null
    });

    // 연결 확인 응답
    socket.emit('connected', {
        socketId: socket.id,
        serverTime: new Date().toISOString()
    });
});
```

### 5.2 세션 생성 플로우

**메시지 흐름**:

```
[Client: Game]                [Server]                [Client: Sensor]
      |                           |                           |
      |--create-session---------->|                           |
      |    {gameId, gameType}     |                           |
      |                           |                           |
      |                      [SessionManager]                 |
      |                      세션 생성                         |
      |                      6자리 코드 생성                   |
      |                           |                           |
      |<--session-created---------|                           |
      |    {sessionCode, ...}     |                           |
      |                           |                           |
      |   QR 코드 표시             |                           |
      |                           |                           |
      |                           |<--connect-sensor----------|
      |                           |    {sessionCode}          |
      |                           |                           |
      |                      세션 검증                         |
      |                      센서 등록                         |
      |                           |                           |
      |<--sensor-connected--------|                           |
      |                           |--sensor-connected-------->|
      |                           |                           |
```

**코드 구현**:

```javascript
// 클라이언트: 세션 생성 요청
async createSession() {
    return new Promise((resolve, reject) => {
        this.socket.emit('create-session', {
            gameId: this.config.gameId,
            gameType: this.config.gameType
        });

        this.socket.once('session-created', (data) => {
            this.sessionCode = data.sessionCode;
            resolve(data);
        });

        setTimeout(() => reject(new Error('세션 생성 타임아웃')), 10000);
    });
}

// 서버: 세션 생성 처리
socket.on('create-session', async (data) => {
    const session = await sessionManager.createSession({
        gameId: data.gameId,
        gameType: data.gameType,
        maxPlayers: data.gameType === 'solo' ? 1 :
                    data.gameType === 'dual' ? 2 : 4
    });

    // 소켓을 세션 룸에 조인
    socket.join(`session-${session.sessionCode}`);

    // 응답
    socket.emit('session-created', {
        sessionCode: session.sessionCode,
        gameId: session.gameId,
        gameType: session.gameType
    });
});
```

### 5.3 센서 데이터 전송 플로우

**실시간 데이터 스트림**:

```
[Sensor Client]            [Server]              [Game Client]
      |                       |                        |
      |--sensor-data--------->|                        |
      |  50ms 간격             |                        |
      |  {orientation, ...}   |                        |
      |                       |                        |
      |                  룸에 브로드캐스트              |
      |                       |                        |
      |                       |--sensor-update-------->|
      |                       |  {data, timestamp}     |
      |                       |                        |
      |                       |                   게임 로직 적용
      |                       |                   Canvas 렌더링
      |                       |                        |
```

**코드 구현**:

```javascript
// 센서 클라이언트: 데이터 전송
collector.on('data', (sensorData) => {
    sdk.sendSensorData(sensorData);
});

// SessionSDK: sendSensorData 메서드
sendSensorData(data) {
    if (!this.sessionCode) {
        console.warn('[SDK] 세션이 없어 센서 데이터를 전송할 수 없습니다.');
        return;
    }

    this.socket.emit('sensor-data', {
        sessionCode: this.sessionCode,
        data: data,
        timestamp: Date.now()
    });
}

// 서버: 센서 데이터 중계
socket.on('sensor-data', (data) => {
    const { sessionCode, data: sensorData, timestamp } = data;

    // 세션 룸에 브로드캐스트 (자신 제외)
    socket.to(`session-${sessionCode}`).emit('sensor-update', {
        data: sensorData,
        timestamp: timestamp
    });
});

// 게임 클라이언트: 데이터 수신
sdk.on('sensor-update', (event) => {
    const { data, timestamp } = event.detail || event;
    processSensorData(data);
});
```

### 5.4 에러 처리 및 재연결

```javascript
// 연결 에러 처리
socket.on('connect_error', (error) => {
    console.error('[WebSocket] 연결 에러:', error);

    this.dispatchEvent(new CustomEvent('connection-error', {
        detail: { error: error.message }
    }));
});

// 자동 재연결
socket.on('disconnect', (reason) => {
    console.log('[WebSocket] 연결 종료:', reason);

    if (reason === 'io server disconnect') {
        // 서버가 강제로 연결을 끊음 - 재연결하지 않음
        this.dispatchEvent(new CustomEvent('disconnected', {
            detail: { reason: reason }
        }));
    } else {
        // 자동 재연결 시도
        if (this.config.autoReconnect) {
            console.log('[WebSocket] 재연결 시도 중...');
            setTimeout(() => {
                socket.connect();
            }, this.config.reconnectionDelay || 1000);
        }
    }
});

// 재연결 성공
socket.on('reconnect', (attemptNumber) => {
    console.log(`[WebSocket] 재연결 성공 (시도 ${attemptNumber}회)`);

    // 기존 세션 복구
    if (this.sessionCode) {
        socket.emit('rejoin-session', {
            sessionCode: this.sessionCode
        });
    }

    this.dispatchEvent(new CustomEvent('reconnected', {
        detail: { attempts: attemptNumber }
    }));
});
```

---

## 6. 권한 검증 플로우

### 6.1 인증 플로우

**로그인 프로세스**:

```
클라이언트: 로그인 요청
    ↓
POST /api/auth/login
{ email, password }
    ↓
Supabase Auth 검증
    ↓
JWT 토큰 발급
    ↓
응답: { token, user }
    ↓
클라이언트: localStorage 저장
    ↓
이후 모든 요청에 Authorization 헤더 포함
```

**코드 구현**:

```javascript
// server/routes/authRoutes.js:45-88
router.post('/login', async (req, res) => {
    const { email, password } = req.body;

    try {
        // 1. Supabase Auth 로그인
        const { data, error } = await supabase.auth.signInWithPassword({
            email: email,
            password: password
        });

        if (error) {
            return res.status(401).json({
                success: false,
                message: '로그인 실패: ' + error.message
            });
        }

        // 2. 사용자 정보 조회
        const { data: profile } = await supabase
            .from('profiles')
            .select('*')
            .eq('id', data.user.id)
            .single();

        // 3. JWT 토큰 반환
        res.json({
            success: true,
            token: data.session.access_token,
            user: {
                id: data.user.id,
                email: data.user.email,
                role: profile?.role || 'user'
            }
        });

    } catch (error) {
        res.status(500).json({
            success: false,
            message: '서버 에러: ' + error.message
        });
    }
});
```

### 6.2 권한 검증 미들웨어

**인증 확인**:

```javascript
// server/middleware/authMiddleware.js:45-125
async function verifyAuth(req, res, next) {
    // 1. Authorization 헤더 확인
    const authHeader = req.headers.authorization;

    if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return res.status(401).json({
            success: false,
            message: '인증 토큰이 없습니다.'
        });
    }

    // 2. 토큰 추출
    const token = authHeader.substring(7);  // "Bearer " 제거

    try {
        // 3. Supabase로 토큰 검증
        const { data: { user }, error } = await supabase.auth.getUser(token);

        if (error || !user) {
            return res.status(401).json({
                success: false,
                message: '유효하지 않은 토큰입니다.'
            });
        }

        // 4. 사용자 정보를 req 객체에 추가
        req.user = {
            id: user.id,
            email: user.email
        };

        // 5. 다음 미들웨어로
        next();

    } catch (error) {
        res.status(500).json({
            success: false,
            message: '인증 확인 실패: ' + error.message
        });
    }
}
```

**게임 소유권 검증**:

```javascript
// server/middleware/authMiddleware.js:167-217
async function checkGameOwnership(req, res, next) {
    const { gameId } = req.params;
    const userId = req.user.id;
    const userEmail = req.user.email;

    try {
        // 1. admin@admin.com은 모든 권한
        if (userEmail === 'admin@admin.com') {
            console.log('[Auth] 관리자 권한으로 접근 허용');
            req.isOwner = true;
            req.isAdmin = true;
            return next();
        }

        // 2. 게임 정보 조회
        const { data: game, error } = await supabase
            .from('generated_games')
            .select('creator_id')
            .eq('game_id', gameId)
            .single();

        if (error || !game) {
            return res.status(404).json({
                success: false,
                message: '게임을 찾을 수 없습니다.'
            });
        }

        // 3. 소유권 확인
        if (game.creator_id !== userId) {
            return res.status(403).json({
                success: false,
                message: '이 게임을 수정할 권한이 없습니다.'
            });
        }

        // 4. 권한 있음
        req.isOwner = true;
        req.isAdmin = false;
        next();

    } catch (error) {
        res.status(500).json({
            success: false,
            message: '권한 확인 실패: ' + error.message
        });
    }
}
```

### 6.3 RLS (Row Level Security) 정책

**Supabase RLS 정책**:

```sql
-- generated_games 테이블 RLS 정책

-- 1. SELECT: 모든 사용자가 읽기 가능
CREATE POLICY "게임 목록 조회 허용"
ON public.generated_games
FOR SELECT
USING (true);

-- 2. INSERT: 인증된 사용자, creator_id 검증
CREATE POLICY "게임 생성 허용"
ON public.generated_games
FOR INSERT
WITH CHECK (
    auth.uid() IS NOT NULL
    AND creator_id = auth.uid()
);

-- 3. UPDATE: 본인 또는 admin만 수정 가능
CREATE POLICY "게임 수정 허용"
ON public.generated_games
FOR UPDATE
USING (
    auth.uid() = creator_id
    OR auth.email() = 'admin@admin.com'
);

-- 4. DELETE: 본인 또는 admin만 삭제 가능
CREATE POLICY "게임 삭제 허용"
ON public.generated_games
FOR DELETE
USING (
    auth.uid() = creator_id
    OR auth.email() = 'admin@admin.com'
);
```

**RLS 동작 원리**:

```
클라이언트 요청
    ↓
Supabase 클라이언트 (JWT 토큰 포함)
    ↓
PostgreSQL RLS 정책 평가
    ↓
auth.uid() = creator_id?
    ↓ YES           ↓ NO
권한 있음      auth.email() = 'admin@admin.com'?
    ↓                   ↓ YES        ↓ NO
쿼리 실행          권한 있음      권한 없음 (403)
```

---

## 7. 세션 관리 플로우

### 7.1 세션 생성 및 저장

**SessionManager 프로세스**:

```javascript
// server/SessionManager.js:78-156
async createSession({ gameId, gameType, maxPlayers }) {
    console.log('[SessionManager] 세션 생성 시작');

    // 1. 고유 세션 코드 생성 (6자리)
    const sessionCode = this.generateSessionCode();
    console.log(`[SessionManager] 세션 코드: ${sessionCode}`);

    // 2. 세션 객체 생성
    const session = {
        sessionCode: sessionCode,
        gameId: gameId,
        gameType: gameType,
        maxPlayers: maxPlayers,
        createdAt: new Date().toISOString(),
        status: 'waiting',           // 'waiting', 'active', 'ended'
        sensors: [],                 // 연결된 센서 목록
        gameSocket: null,            // 게임 소켓 ID
        sensorSockets: []            // 센서 소켓 ID들
    };

    // 3. 메모리에 저장
    this.sessions.set(sessionCode, session);

    console.log(`[SessionManager] 세션 생성 완료: ${sessionCode}`);

    return session;
}

// 고유 코드 생성
generateSessionCode() {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    let code = '';

    // 중복 방지를 위해 루프
    do {
        code = '';
        for (let i = 0; i < 6; i++) {
            code += chars.charAt(Math.floor(Math.random() * chars.length));
        }
    } while (this.sessions.has(code));

    return code;
}
```

### 7.2 센서 연결 관리

```javascript
// server/SessionManager.js:158-234
async connectSensor(sessionCode, sensorSocketId) {
    console.log(`[SessionManager] 센서 연결: ${sessionCode}`);

    // 1. 세션 조회
    const session = this.sessions.get(sessionCode);

    if (!session) {
        throw new Error('유효하지 않은 세션 코드입니다.');
    }

    // 2. 최대 플레이어 수 확인
    if (session.sensors.length >= session.maxPlayers) {
        throw new Error('세션이 꽉 찼습니다.');
    }

    // 3. 센서 정보 생성
    const sensor = {
        id: `sensor-${Date.now()}`,
        socketId: sensorSocketId,
        connectedAt: new Date().toISOString(),
        playerNumber: session.sensors.length + 1
    };

    // 4. 세션에 센서 추가
    session.sensors.push(sensor);
    session.sensorSockets.push(sensorSocketId);

    // 5. 세션 상태 업데이트
    if (session.sensors.length === session.maxPlayers) {
        session.status = 'active';
        console.log(`[SessionManager] 세션 활성화: ${sessionCode}`);
    }

    console.log(`[SessionManager] 센서 연결 완료: ${sensor.id}`);

    return { session, sensor };
}
```

### 7.3 세션 정리 및 타임아웃

```javascript
// server/SessionManager.js:289-345
cleanupInactiveSessions() {
    console.log('[SessionManager] 비활성 세션 정리 시작');

    const now = Date.now();
    const timeoutMs = 30 * 60 * 1000;  // 30분

    let cleanedCount = 0;

    for (const [sessionCode, session] of this.sessions.entries()) {
        const createdAt = new Date(session.createdAt).getTime();
        const age = now - createdAt;

        // 30분 이상 경과한 세션 삭제
        if (age > timeoutMs) {
            this.sessions.delete(sessionCode);
            cleanedCount++;
            console.log(`[SessionManager] 세션 삭제: ${sessionCode} (${Math.round(age / 60000)}분 경과)`);
        }
    }

    console.log(`[SessionManager] 정리 완료: ${cleanedCount}개 세션 삭제`);
}

// 주기적 정리 (10분마다)
setInterval(() => {
    this.cleanupInactiveSessions();
}, 10 * 60 * 1000);
```

### 7.4 세션 상태 전환

**상태 다이어그램**:

```
[waiting]
   ↓
센서 연결 (첫 번째 센서)
   ↓
[waiting]
   ↓
센서 연결 (maxPlayers 도달)
   ↓
[active]
   ↓
게임 종료 또는 연결 끊김
   ↓
[ended]
   ↓
세션 정리
   ↓
[삭제됨]
```

**코드 구현**:

```javascript
// 상태 전환 메서드
updateSessionStatus(sessionCode, newStatus) {
    const session = this.sessions.get(sessionCode);

    if (!session) {
        throw new Error('세션을 찾을 수 없습니다.');
    }

    const oldStatus = session.status;
    session.status = newStatus;
    session.updatedAt = new Date().toISOString();

    console.log(`[SessionManager] 세션 상태 변경: ${sessionCode} (${oldStatus} → ${newStatus})`);

    // 상태별 처리
    switch (newStatus) {
        case 'active':
            // 게임 시작 알림
            this.notifyGameStart(session);
            break;

        case 'ended':
            // 세션 종료 알림 및 타임아웃 설정
            this.notifyGameEnd(session);
            setTimeout(() => {
                this.sessions.delete(sessionCode);
            }, 5 * 60 * 1000);  // 5분 후 삭제
            break;
    }

    return session;
}
```

---

## 요약

이 문서는 Sensor Game Hub의 7가지 핵심 시스템 플로우를 상세히 분석했습니다:

1. **AI 게임 생성 플로우**: 5단계 프로세스 (아이디어 분석 → RAG 검색 → Claude 생성 → 검증 → 저장)
2. **센서 게임 플레이 플로우**: QR 코드 → 센서 연결 → 실시간 데이터 전송 → 게임 로직
3. **유지보수 플로우**: 버그 수정, 기능 추가, 자동 버전 관리
4. **RAG 검색 플로우**: 문서 임베딩, pgvector 유사도 검색
5. **WebSocket 통신 플로우**: 연결, 세션 생성, 센서 데이터 중계
6. **권한 검증 플로우**: JWT 인증, 미들웨어, RLS 정책
7. **세션 관리 플로우**: 세션 생성, 센서 연결, 상태 관리, 정리

각 플로우는 실제 코드 구현, 데이터 흐름, 에러 처리를 포함하여 면접에서 전체 시스템을 완벽하게 설명할 수 있도록 구성되었습니다.

---

**다음 문서**: [07_기술적_의사결정.md](./07_기술적_의사결정.md)
